Truck_Project1_notes.txt

Truck_Project1 is an automotive SCADA system which uses a Xilinx Spartan-3E to 
monitor real-time data, a PIC24FJ128GB110 to handle a keypad and route message
traffic, a ATMEGA328P to drive a t6963 LCD screen, and a TS-7200/7800 to do
I/O (turning on and off lights and reading switches).


											   | AVR |=> LCD
												  ^
----|											  |
	|											  |
	|											  |							  Laptop
F	|											  |								^
P	|											  v								|TCP/IP
G	|---------------> RS-232* ----------------->| P	|							|
A	|											| I	|							v
	|						|-----------|		| C |						|-----------|
----|						|			|		| 2	|						|			|	
							|  keypad	|------>| 4 |<------ RS-232 ------->| TS-7800	|
							|			|									|			|
							|-----------|									|-----------|

* there is also a SPI connection between the FPGA and the PIC24			
the PIC24FJ128GB110 (PIC) will route message traffic to and from the FPGA, the 
TS-7200 and the LCD screen.

The menuing of the LCD screen and can display optional real time info like engine speed,
engine temp, oil pressure etc coming directly from the FPGA.

There will also be a task to read the ADC's which measure temp sensors and the oil pressure.
The FPGA has 2 serial ports (transmit only) that send rpm & mph data to a couple of off-the-
shelf 4 digit LED's that will be on the dashboard. The FPGA also sends the rpm & mph data to
the PIC via the SPI (as master).

Other telemetry data can be added later like distributor timing to use for spark advance.
The TS-7200 has a removable (not hot-swapable) compact flash disk so the idea is to have a 
'black box' FDR that records the last so many hours or minutes of the telemetry data to a
file that can be downloaded later.

directories:
PIC24_support - source and libs for PIC24FJ128GB110 (uses MPLAB X)
AVR_t6963 - ATMEGA328p source and support files (uses avrdude)
thread_io - source for the TS-7200/7800 cards (from Technologic Systems)
thread_io/ncurses - source for the ncurses program that runs on the laptop and communicates
						with the TS-7200/7800.
Truck_App1 - source for the FPGA (Xilinx Spartan-3E) in VHDL

The PIC24 uses a really nice RTOS called ESOS which is from people at Mississippi State.
(see https://sites.google.com/site/pic24micro//Home/Course)
within the PIC24_support directory there is /lib and /esos. lib is the src & include
for using a PIC24 (or most other 16-bit controllers from Microchip*) while the esos
directory is the RTOS which uses some of the /lib directory files. There is a file in
the PIC24_support directory called esos_examples.c that explains how to use the ESOS system.

*Microchip was bought out by AVR so you have to go to the AVR site to find the documentation.

The thread_io directory has files used to compile an embedded linux program that uses
the POSIX pthread library to handle serial io and tcp/ip traffic and drive a io card that
plugs into the TS-7XXX PC-104 bus. I bought the cards used on ebay. They are orginally from
Tri-M Engineering. Each card has 20 inputs and 20 outputs. The outputs are small 5A relays
onboard the card. The cards can be set to accessed and different memory/io addresses so up
to 4 can be stacked on each other. I've tried just about every free RTOS out there and
no-one seems to have the ports to work on the TS-7200 which use the ARM920T processor with
the EP9301 chipset. I like the uCOS-II Jean J. Labrosse of Micrium, Weston, FL and he has
the port files for the ARM processor but I wasn't inclined to take a year-long self-course
on ARM assembly language, linux internals and the ARM architecture, although I did 'hack'
through it for a while. So using the POSIX pthreads are a pretty good alternative and you
can learn more about pthreads from 'Pthreads Programming' by Dick Buttlar from O'Reilly.

The Truck_App1 directory has all the files for compiling (if you want to call it that)
a Spartan-3E FPGA from Xilinx. The files ending in .vhd are the VHDL programming language
and I used a free copy of ISE from Xilinx. Actually, I tried to download it from the 
Xilinx website recently and its not exactly free since now you have to have a verifiable
company and phone no. so I'm using a free copy I downloaded a couple years ago. The
particular board running this is called an XC3S500E which only has the Spartan-3E chip,
the clock and the pinout connectors for no less that 200 io pins. These can be purchased
on ebay for about $35USD. All the other development boards have all the buttons, LEDs,
DB connectors and USB ports which I didn't need. The only problem with the io connectors
with these is that they are not the standard 1mm pitch that fits nicely into most
perfboards which is what I'm using since I'm not into making my own printed circuit
boards. If you can find a copy of ISE from Xilinx, it also comes with a simulator called
ISim which lets you see how your VHDL program works and is really useful for testing
and debugging the FPGA. The other alternative to Xilinx would be Altera which is probably
geared more towards the hobbiest, I would think, but I'm too far down the rabbit hole
now. If you want a copy of ISE, email me at hwswhacker1256@gmail.com and I'll see if
I can get the file to you via ftp or something.

You can learn more about VHDL and FPGA by doing a google search but here's the executive
summary: 

With most modern micropressors and microcontrollers you write a program in C/C++ or
whatever, compile it to a binary file, load it to the processor memory and the hardware
on the chip executes each instruction from the binary file step by step. With the FPGA
(Field Programmable Gate Array) the VHDL code lets you build the hardware or the
processor core. In other words, the ISE development system actually routes the 
connections on the chip so you can have parallel processes running completely
independent of each other in real time. This is really powerful when doing high speed
data aquisition but its a steep learning curve. The ISim is really helpful and I took
most of my code from the examples from the book 'FPGA Prototyping by VHDL example' by
Pong. P. Chu. 

The thread_io/ncurses directory has all the source and support files for compiling a
linux program that runs on any linux desktop and uses ncurses to communicate over a
tcp/ip connection to the TS-7200/7800 box. The program running on the TS-7XXX box
opens a couple binary files ending in .dat which are a data base where each record is
a configuration for each of the 20 io ports. The dat files starting with an 'o' are
for the the 20 output ports and the dat files starting with an 'i' are for the 20
input ports. Basically, when there is a change on one of the inputs, it can effect
any one of the 20 outputs. So that way you can assign different outputs to inputs.
The ncurses program lets you change the configuration or load different dat files.
This can be kind of dicey for things like the starter motor so the ioport assigned
to the start switch only activates a relay that enables a button on the dash to close
the circuit the the actual starter solinoid. 

when compiling for TS-7200:
edit thread_io/Makefile so it compiles for TS-7200:

#use this for TS-7200
CC_FLAGS = -static -g -DMAKE_TARGET -Wstrict-prototypes -mcpu=arm920t
#use this for TS-7800
#CC_FLAGS = -static -g -DTS_7800 -DMAKE_TARGET -Wstrict-prototypes -mcpu=arm920t

the client program (in ncurses directory) takes the ip address as the 1st param
the 2nd & 3rd params are optional idata & odata files.

currently the cards are configured for:
 "192.168.42.146"	TS-7200
 "192.168.42.148"		"
 "192.168.42.149"		"
 "192.168.42.145"	TS-7250
 "192.168.42.124"	TS-7250

if using the make file for the simulator: thread_io/linux_make, 
use the ip address for the linux box as 1st param for client
of the linux box that the sched simulator is running on

config jumpers for io card:
base address		JP1		JP2
0x240				0		0
0x260				0		1
0x280				1		0
0x300				1		1

JP1 	JP2 (see note 1)
123		123
on for JP1 is jumper from 1->2
on for JP2 is jumper from 2->3

card on top is configured starting at 0x280
bottom card is 0x300 

PortA outputs 0x280	(8 bits)
PortB outputs 0x281	(8 bits)
PortC outputs 0x282	(4 bits)

PortD outputs 0x300	(8 bits)
PortE outputs 0x301	(8 bits)
PortF outputs 0x302	(4 bits)

PortA inputs 0x284	(8 bits)
PortB inputs 0x285	(8 bits)
PortC inputs 0x286	(4 bits)

PortD inputs 0x304	(8 bits)
PortE inputs 0x305	(8 bits)
PortF inputs 0x306	(4 bits)
(see ioports.h)

relays start at upper left and go down then lower right and go up (see note 1)

		left side		right side

		1				20
		2				19
		3				18
		4				17
		5				16
		6				15
		7				14
		8				13
		9				12
		10				11

inputs start from left (see note 1)
note 1) looking at card from component side w/PC-104 on bottom:

perf board for flashing light and 2 buttons:

pins at bottom:
1) +5v
2) gnd
3) LED light (to DIO1 7)
4) green button (to DIO1_0)
5) read button (to DIO1_1)

A 4x4 keypad is attached to the PIC24 so when a key is pressed, one of the 
following bytes is decoded:

0xE0 - '#'
0xE1 - '*'
0xE2 - '0'
0xE3 - '1'
0xE4 - '2'
0xE5 - '3'
0xE6 - '4'
0xE7 - '5'
0xE8 - '6'
0xE9 - '7'
0xEA - '8'
0xEB - '9'
0xEC - 'A'
0xED - 'B'
0xEE - 'C'
0xEF - 'D'

(Alternatively, the PIC can get the keypresses from one of the comm ports and double
as the keypad)

keypad layout - since the six reassignable keys are on the outside (bottom and left) it makes
sense to use these as special function keys.

1 2 3 A
4 5 6 B
7 8 9 C
* 0 # D

dec		hex		char
35		23		#
42		2a		*
48		30		0
49		31		1
50		32		2
51		33		3
52		34		4
53		35		5
54		36		6
55		37		7
56		38		8
57		39		9
65		41		A
66		42		B
67		43		C
68		44		D

				
The TS-7200 uses comm1 as a monitor but can be disabled and used as an extra serial port
as long as the sched program can start automatically. Since I really don't need an extra
serial port on the TS-7200 I can just have a DB9 connector wired out to the dashboard
and possibly a switch attached to the jumper on the TS-7200 board which disabled comm1
used as a monitor. The TS-7200 uses the ethernet connector as a TCP/IP server so a linux
box running the client program (/dev/thread_io/ncurses) can be hooked up and and the 
client can log on and off at anytime.

So currently there is an extra serial port available on the FPGA and one extra on the
TS-7200.

The dashboard will have a DB9 connector for the TS-7200 monitor and one for the FPGA
plus a RJ-45 connector to the TS-7200 ethernet port. (Use a crossover ethernet cable
from the linux laptop to the RJ-45 jack - or use a old D-link router as hub in case
for another client to log into the TS-7200).

The dashboard will have programming connectors for:
1) the PIC24 - 6 pin din
2) 14 pin ICD connector to program the FPGA
3) the programmer for the AVR - 4 pins

The TS-7200 has a reset button on board and can be re-wired to bring it out to the
dashboard.

So the 2 DB9 connectors, the 3 programming jacks, the RJ-45 jack, the reset buttons
and the on/off switches can be in a panel with a cover so it can be opened only for
upgrading, testing and debugging.

FPGA connections:

1) 2 inputs for the mph & rpm and alternately, another rpm for the optional
		missing tooth wheel.
2) a tone-generator output which goes to a speaker.
3) an output which breaks the circuit to the fuel pump.
4) other optional IO for future expansion.

The inputs to the FPGA should have 5v clamping diodes which go to a 5v-3v3 converter.

PIC24 connections:

1) 8 or 16 inputs for the ADC (eng temp & oil pressure to start with)
2) other IO for future expansion.

The TS-7200 has connectors for the I/O (PC-104 card) - inputs from external switches or
momentary contact push-buttons - outputs go either directly to lights 
(dash indicator lights) or to high-amp relays (headlights, starter relay, etc)

TS-7200:
2 UARTs are RS-232 - 1 goes to PIC24, the other is open
The ehternet is for a monitor (use cross-over cable to laptop)

PIC24:
1 UART goes to TS-7XXX (5-3v3 conv to RS-232 conv)
SPI goes to FPGA (4k7 pull-up resistors)

FPGA:
1 UART goes to monitor (5-3v3 conv to RS-232 conv)

"make set_eeprom_save_fuse" to set fuses so eeprom is saved when reprogramming
"make clear_eeprom_save_fuse" to set fuses so eeprom gets erased everytime

(10/13/17)
TS-7800:
Has 3 UARTS, faster CPU & better OS. Memory access is diff for DIO/LCD & PC104.
No built-in SPI like the TS-7200 but very little docs on the Marvell processor. 
(would be nice to have interrupt routine that handles the SPI which the pins could be
on the DIO. Since the TS-7800 is in a remote box we have to use serial anyway).

(10/25/17)
added 2 branches: TS-7200 & TS-7800 but made changes in master so the Makefile in
thread_io can be changed to compile for either one. (search for "-DTS-7800")
also need to change the init_client(HOSTn) in demo_menus2.c and client.c in ncurses
according to the defines in client.h: 

(4/29/18)
did away with all the menuing stuff in AVR which was a gigantic menuing system which was
supposed to be configurable. Long story short, the esos RTOS can't send mail messages
from regular functions, even when called from and esos task, nor can you call any
ESOS_TASK macros so now the menu choices and screen display will just have to be
hard-coded in for whatever is needed.

Don't use the functon pointer array in the thread_io, just have dedicated threads
and have the serial port one with the highest priority.

Order another 2GB SD card for the TS-7800 to back up OS on.

Get all the ssh's to use keygen instead of passwords

Add extra behavoir info to the I_DATA struct:

typedef struct o_data
{
	char label[20];
	UCHAR port;
	UCHAR onoff;			// 1 of on; 0 if off
	UCHAR type;
	UINT time_delay;
	UCHAR pulse_time;
} O_DATA;

typedef struct i_data
{
	char label[ILABELSIZE];
	UCHAR port;
	UCHAR affected_output;
	UINT temp;
} I_DATA;

type:
0) regular - on/off state doesn't change until user tells it to
1) on for time delay seconds and then it goes back off
2) goes on/off at a pulse_time rate until turned off again
4) goes on/off at pulse_time rate for time_delay seconds and then back off
5) toggle switch realized in momentary push-buton: push & release of a 
	momentary push-button turns bit on or off

1 task scans all the outputs using ollist_find_data and if type != 0 && onoff == 1 then
read last_time_state_changed (UINT) in current O_DATA and check against current time using localtime
in this case onoff == 1 means its active 


10/16/17
made separate make files (make_db) to compile init_db & list_db on both host and target side
/thread_io (target) - sched
/thread_io/ncurses (host) - client

did away with curr_i_array & curr_o_array and just used the ill & oll linked lists
menus:
1) Host
	("Open"),						  // 0
	("Save File"),					  // 1
	("Edit idata"),					  // 2
	("Edit odata"),					  // 3
	("Exit"),						  // 4
	("Shift Left"),					  // 5
	("Shift Right"),				  // 6

2) Target
	("Open"),						  // 0
	("Save File"),					  // 1
	("Save As"),					  // 2
	("Delete"),						  // 3
	("List idata"),					  // 4
	("List odata"),					  // 5
	("Send idata"),					  // 6
	("Send odata"),					  // 7
	("Show All"),					  // 8

3) Tool
	"Connect"),					// 0
	"Disconnect"),				// 1
	"Enable Start"),			// 3	close ckt to start relay for time delay x
										turn on fuel pump
										turn on fan after time delay y
	"On Fuel Pump"),			// 4
	"Off Fuel Pump"),			// 5
	"On Fan"),					// 6
	"Off Fan"),					// 7
	"Shutdown"),				// 8	turn of all
	"Clear Screen"),			// 9


got the following strange error:
	A clock IOB / clock component pair have been found that are not placed at an optimal clock IOB /
   clock site pair. The clock component <reset_IBUF_BUFG> is placed at site <BUFGMUX_X2Y0>. 
   The IO component <reset> is placed at site <IPAD119>.  This will not allow the use of the
   fast path between the IO and the Clock buffer. This is normally an ERROR but the 
   CLOCK_DEDICATED_ROUTE constraint was applied on COMP.PIN <reset.PAD> allowing your design
   to continue. This constraint disables all clock placer rules related to the specified COMP.PIN. 
   The use of this override is highly discouraged as it may lead to very poor timing results. 
   It is recommended that this error condition be corrected in the design.
then added the line:
NET "reset" CLOCK_DEDICATED_ROUTE = FALSE;
in the ucf file to turn it to a warning after trying for 3 days to fix it. Some kind of 
timing problem...

Need another database which has list of on-off times for each IO port. Have a field in
the O_DATA database which points to a on-off database (or text file).
In task2 when we check for a change in the inputs, check for a time-up in a list of
which active time-up array and then check the time of day to see if that port should
be turned on or off.

Use 12vdc->5vdc converter from separate motorcycle battery to power whole system.
Then have a way to keep the battery charged - either charge it from the car battery
or use solar panels (or switch between both)

to mount sd card for TS-7200 see thread_io/how2formatSDCardExt.png and mountcf.sh
(also see: https://www.tldp.org/HOWTO/Flash-Memory-HOWTO/ext2.html)

to manage TS-7200 bios see thread_io/manage_boot_bios.txt

**************** nice to have's: ****************

FPGA reads from missing tooth wheel for the crank position and calculates the amount
of necessary spark advance to control the distributor

Use the ts-bat3 battery backup on the stack.

TS-7800 has (2) SATA connectors for SSD drives. 

One of the TS-7200's have the PC104 pins going thru the bottom - we could put the bat3
on top of it and the other IO boards underneath which might be safer.

Find out how to get TS-7200 to use the pthreadlib in its lib dir so we don't have to
send it over as a static.

Instead of ncurses program running on laptop, just gen up a PHP web interface and use
the brower. (see dev2/TS-7260/www/)

make an extra field in the O_DATA and I_DATA structs called group for acting on a group

need a way to enter password (alnum stuff)

GPS and accel modules on FPGA (serial?)

cadmium sulfide photodetector under windshield for measuing light level to 
dim display to rpm/mph LED's and LCD screen automatically.

PWM signal from PIC24 controls SCR power to the LCD (to dim display)

LOAD_RAM needs the transmit/receiveByte calls

get alnum to work - just do it like the edit boxes only A->D is printed and
'*' is escape and '#' is 'enter'

do/init_exec has prompts but not part of check_boxes[]

any checkbox can apply to a 'group' IO

have a 100 or so byte section at beginning of dat files (just after the id tag) reserved
for comments that can be edited and viewed.

Use ESP8266 for remote wireless (bluetooth) control from Android phone (remote start
- alarm disable - door poppers)
