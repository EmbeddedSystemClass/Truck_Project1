Truck_Project1_notes.txt

Truck_Project1 is an automotive SCADA system which uses a Xilinx Spartan-3E to 
monitor real-time data, a PIC24FJ128GB110 to handle a keypad and route message
traffic, a ATMEGA328P to drive a t6963 LCD screen, and a TS-7200/7800 to do
I/O (turning on and off lights and reading switches).


  												| AVR |===> t6963 LCD screen
  												  ^
  												  | RS-232
----|											  |							Laptop (optional)
	|											  |							    ^
F	|											  |								|
P	|											  v								|TCP/IP
G	|<--------------> RS-232 ------------------>| S	|							|
A	|											| T	|							v
	|						|-----------|		| M |						|-----------|
----|						|			|		| 3	|						|			|	
							|  keypad	|======>| 2 |<------ RS-232 ------->| TS-7800	|
							|			|									|			|
							|-----------|									|-----------|

the STM32F100RB (STM32) will route message traffic to and from the FPGA, the 
TS-7200 and the LCD screen.

The menuing of the LCD screen and can display optional real time info like engine speed,
engine temp, oil pressure etc coming directly from the FPGA.

There will also be a task to read the ADC's which measure temp sensors and the oil pressure
(among other things like the photodiode behind the windshield).
The FPGA has 2 serial ports (transmit only) that send rpm & mph data to a couple of off-the-
shelf 4 digit LED's that will be on the dashboard. The FPGA also sends the rpm & mph data to
the PIC via the serial port.

Other telemetry data can be added later like distributor timing to use for spark advance.

directories:
STM32 - directory created by STMCubeMX used to generate the FreeRTOS tasks, queues and periferals

AVR_t6963 - ATMEGA328p source and support files (uses avrdude)

thread_io - source for the TS-7200/7800 cards (from Technologic Systems)

thread_io/cs_client - source for init_db & list_db (programs used to manage odata.dat db) and other
	source files

thread_io/cs_client/EpServerClient - Visual Studio project for tcp client that runs on laptop in
	vehicle as car PC and supplementary server that runs on desktop in garage to talk to laptop
	over WiFi.

thread_io/test_tcp - other stuff used in project: 
	server.c is an ARM compiled file that downloads the new sched after the TS-7200 exits with a 
	special return code which instructs the bash file to run 'server' to talk to a program called
	'SendFile' which runs from the laptop to send the new sched file.
	show_params.c and make_params.c are used to show and make the param.conf config file which
	the sched program keeps track of config data.
	test_ioports and test_inports are used to test the io daughter cards 

Truck_App1 - source for the FPGA (Xilinx Spartan-3E) in VHDL

The STM32 directory has the source files used by TrueStudio to compile the hex file to download
to the STM32F100RB. I use the ST32 ST-LINK utility which programs the STM32 over a USB port.
The STM32 program was generated by using STM32CubeMX. There are only certain sections of the code
which the user can modify. Anything else gets deleted when you pull the project into CubeMX.
The project was generated to use FreeRTOS.

The thread_io directory has files used to compile an embedded linux program that uses
the POSIX pthread library to handle serial io and tcp/ip traffic and drive a io card that
plugs into the TS-7XXX PC-104 bus. I bought the cards used on ebay. They are made by
Tri-M Engineering. Each card has 20 inputs and 20 outputs. The outputs are small 5A relays
onboard the card. The cards can be set to access different memory/io addresses so up
to 4 can be stacked on each other. I've tried just about every free RTOS out there and
no-one seems to have the ports to work on the TS-7200 which use the ARM920T processor with
the EP9301 chipset. I like the uCOS-II Jean J. Labrosse of Micrium, Weston, FL and he has
the port files for the ARM processor but I wasn't inclined to take a year-long self-course
on ARM assembly language, linux internals and the ARM architecture, although I did 'hack'
through it for a while. So using the POSIX pthreads are a pretty good alternative and you
can learn more about pthreads from 'Pthreads Programming' by Dick Buttlar from O'Reilly.

The Truck_App1 directory has all the files for compiling (if you want to call it that)
a Spartan-3E FPGA from Xilinx. The files ending in .vhd are the VHDL programming language
and I used a free copy of ISE from Xilinx. Actually, I tried to download it from the 
Xilinx website recently and its not exactly free since now you have to have a verifiable
company and phone no. so I'm using a free copy I downloaded a couple years ago. The
particular board running this is called an XC3S500E which only has the Spartan-3E chip,
the clock and the pinout connectors for no less that 200 io pins. These can be purchased
on ebay for about $35USD. All the other development boards have all the buttons, LEDs,
DB connectors and USB ports which I didn't need. The only problem with the io connectors
with these is that they are not the standard 1mm pitch that fits nicely into most
perfboards which is what I'm using since I'm not into making my own printed circuit
boards. If you can find a copy of ISE from Xilinx, it also comes with a simulator called
ISim which lets you see how your VHDL program works and is really useful for testing
and debugging the FPGA. The other alternative to Xilinx would be Altera which is probably
geared more towards the hobbiest, I would think, but I'm too far down the rabbit hole
now. If you want a copy of ISE, email me at hwswhacker1256@gmail.com and I'll see if
I can get the file to you via ftp or something.

A 4x4 keypad is attached to the STM32 so when a key is pressed, one of the 
following bytes is decoded:

0xE0 - '#'
0xE1 - '*'
0xE2 - '0'
0xE3 - '1'
0xE4 - '2'
0xE5 - '3'
0xE6 - '4'
0xE7 - '5'
0xE8 - '6'
0xE9 - '7'
0xEA - '8'
0xEB - '9'
0xEC - 'A'
0xED - 'B'
0xEE - 'C'
0xEF - 'D'

keypad layout - since the six reassignable keys are on the outside (bottom and left) it makes
sense to use these as special function keys.

1 2 3 A
4 5 6 B
7 8 9 C
* 0 # D

dec		hex		char
35		23		#
42		2a		*
48		30		0
49		31		1
50		32		2
51		33		3
52		34		4
53		35		5
54		36		6
55		37		7
56		38		8
57		39		9
65		41		A
66		42		B
67		43		C
68		44		D

				
The TS-7200 uses comm1 to talk to the STM32 and Comm2 as an optional monitor (see printString2
in thread_io program). The TS-7200 uses the ethernet connector as a TCP/IP server so a linux
box running the client program (/dev/thread_io/ncurses) can be hooked up and and the 
client can log on and off at anytime.

FPGA connections:

1) 2 inputs for the mph & rpm and alternately, another rpm for the optional
		missing tooth wheel.
2) a tone-generator output which goes to a speaker.
3) an output which breaks the circuit to the fuel pump.
4) other optional IO for future expansion.

The inputs to the FPGA should have 5v clamping diodes which go to a 5v-3v3 converter.

AVR Makefile options to save eeprom across flash reprogramming:
"make set_eeprom_save_fuse" to set fuses so eeprom is saved when reprogramming
"make clear_eeprom_save_fuse" to set fuses so eeprom gets erased everytime

(10/13/17)
TS-7800:
Has 3 UARTS, faster CPU & better OS. Memory access is diff for DIO/LCD & PC104.
No built-in SPI like the TS-7200 but very little docs on the Marvell processor. 
(would be nice to have interrupt routine that handles the SPI which the pins could be
on the DIO. Since the TS-7800 is in a remote box we have to use serial anyway).

(10/25/17)
added 2 branches: TS-7200 & TS-7800 but made changes in master so the Makefile in
thread_io can be changed to compile for either one. (search for "-DTS-7800")
also need to change the init_client(HOSTn) in demo_menus2.c and client.c in ncurses
according to the defines in client.h: 

(4/29/18)
did away with all the menuing stuff in AVR which was a gigantic menuing system which was
supposed to be configurable. Long story short, the esos RTOS can't send mail messages
from regular functions, even when called from and esos task, nor can you call any
ESOS_TASK macros so now the menu choices and screen display will just have to be
hard-coded in for whatever is needed.

(9/4/18)
realized if I'm measuring the pulse of 1 plug wire, then I am getting a pulse for 
every 2 revolutions of the crankshaft. So since I couldn't figure out how to set
the RPM_DVND and RPM_CLOCK_COUNT in lib/Common.vhd, I just doubled the result value
in sensor.vhd returned from the averaging algoritm. 

Don't use the functon pointer array in the thread_io, just have dedicated threads
and have the serial port one with the highest priority.

Get all the ssh's to use keygen instead of passwords

got the following strange wtf error:
	A clock IOB / clock component pair have been found that are not placed at an optimal clock IOB /
   clock site pair. The clock component <reset_IBUF_BUFG> is placed at site <BUFGMUX_X2Y0>. 
   The IO component <reset> is placed at site <IPAD119>.  This will not allow the use of the
   fast path between the IO and the Clock buffer. This is normally an ERROR but the 
   CLOCK_DEDICATED_ROUTE constraint was applied on COMP.PIN <reset.PAD> allowing your design
   to continue. This constraint disables all clock placer rules related to the specified COMP.PIN. 
   The use of this override is highly discouraged as it may lead to very poor timing results. 
   It is recommended that this error condition be corrected in the design.
then added the line:
NET "reset" CLOCK_DEDICATED_ROUTE = FALSE;
in the ucf file to turn it to a warning after trying for 3 days to fix it. Some kind of 
timing problem...

when setting VHDL variables in the declaration statement like:
	"signal fubar: std_logic_vector(7 downto 0):= "00000000";"
and then trying to set the variable again in the reset section of the FSM, it will
use the value set in the reset section in the simulator, but when running the program
on the chip, it will use the value set in the declaration. Spent about 3-4 hours
on this one night.

can't call ESOS_TASK_WAIT_TICKS from within mail recipient?

note: don't do any assignment statements before ESOS_TASK_BEGIN()
it causes strange side-effects

**************** todo ****************

added fuel pump shutoff output for FPGA which shuts off fuel pump when rpms go to zero
this must be overridden to start (relay in series with relay controlled by io card)

also added rev limit feature which opens relay in series with io controlled relay for
ignition but might just want to have it set off an alarm - too much gas to carb to shut
off ignition possibly could wash out cylinders ?

Need another database which has list of on-off times for each IO port. Have a field in
the O_DATA database which points to a on-off database (or text file).
In task2 when we check for a change in the inputs, check for a time-up in a list of
which active time-up array and then check the time of day to see if that port should
be turned on or off.
(9-4-18) -this works for types 0-3

sched needs a config file so it knows which dat files were used last instead
of just idata & odata which are loaded by default (see odometer.txt)

When E-Stop button is pushed and if lights are one, the lights will stay on for a preset
amount of time. 

Start making backups of client exe's when uploading new sched's to iobox on vehicle because
if any of the cmd_types get changed in the system and the new client gets started it might
not work with the old sched because it is sending different cmd_types back and forth.
If this happens, then the only way to fix it is to have a linux desktop in the vehicle to
use to ftp into the iobox and upload the new exe. 

1) get dual boot linux/windows desktop with keyboard and mouse and hook up the VGA port to
	the in-dash monitor.
2) with a null-modem RS-232 cable, connect to the iobox to the linux desktop.
3) put the sched on the linux drive and boot up in linux.
4) install a router between the iobox and the desktop
5) ftp into the iobox and load the new sched to the root of the iobox.
6) reboot the desktop into windows and with the new client, make sure everything works.

**************** nice to have's: ****************

use 2 extra pins from FPGA to 25 watt stereo amp using pwm2.vhd to play tunes

FPGA reads from missing tooth wheel for the crank position and calculates the amount
of necessary spark advance to control the distributor

Use the ts-bat3 battery backup on the stack.

TS-7800 has (2) SATA connectors for SSD drives. 

One of the TS-7200's have the PC104 pins going thru the bottom - we could put the bat3
on top of it and the other IO boards underneath which might be safer.

Find out how to get TS-7200 to use the pthreadlib in its lib dir so we don't have to
send it over as a static.

GPS and accel modules on FPGA (serial?)

cadmium sulfide photodetector under windshield for measuing light level to 
dim display to rpm/mph LED's and LCD screen automatically.

have a 100 or so byte section at beginning of dat files (just after the id tag) reserved
for comments that can be edited and viewed.

Use ESP8266 for remote wireless (bluetooth) control from Android phone (remote start
- alarm disable - door poppers)

SEN-12756 Sparkfun 3-Axis Accelerometer MMA8452
SEN-11931 Sparkfun Dig. Temp Sensor TMP102

