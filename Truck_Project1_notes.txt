Truck_Project1_notes.txt

Truck_Project1 is an automotive SCADA system which uses a Xilinx Spartan-3E to 
monitor real-time data, a PIC24FJ128GB110 to handle a keypad and LCD screen,
and a TS-7200/7800 to do I/O (turning on and off lights and reading switches).

											|-------|
----|										| LCD 	|
	|										|-------|
	|											  ^							  Laptop
F	|											  |								^
P	|											  v								|TCP/IP
G	|---------------> RS-232  ----------------->| P	|							|
A	|											| I	|							v
*	|						|-----------|		| C |						|-----------|
----|						|			|		| 2	|						|			|	
							|  keypad	|------>| 4 |<------ RS-232 ------->| TS-7800	|
							|			|									|			|
							|-----------|									|-----------|

			
Basically, the  PIC24FJ128GB110 (PIC) will route message traffic to and from the FPGA, the 
TS-7200 and the LCD screen.

The menuing of the LCD screen and can display optional real time info like engine speed,
engine temp,oil pressure etc coming directly from the FPGA.

There will also be a task to read the ADC's which measure temp sensors and the oil pressure.
The FPGA has 2 serial ports (transmit only) that send rpm & mph data to a couple of off-the-
shelf 4 digit LED's that will be on the dashboard. The FPGA also sends the rpm & mph data to
the PIC via the SPI (as master).

Other telemetry data can be added later like distributor timing to use for spark advance.
The TS-7200 has a removable (not hot-swapable) compact flash disk so the idea is to have a 
'black box' FDR that records the last so many hours or minutes of the telemetry data to a
file that can be downloaded later.

directories:
PIC24_support - source and libs for PIC24FJ128GB110
thread_io - source for the TS-7200/7800
thread_io/ncurses - source for the ncurses program that runs on the laptop and communicates
						with the TS-7200/7800.
Truck_App1 - source for the FPGA (Xilinx Spartan-3E) in VHDL

when compiling for TS-7200:
edit thread_io/Makefile so it compiles for TS-7200:

#use this for TS-7200
CC_FLAGS = -static -g -DMAKE_TARGET -Wstrict-prototypes -mcpu=arm920t
#use this for TS-7800
#CC_FLAGS = -static -g -DTS_7800 -DMAKE_TARGET -Wstrict-prototypes -mcpu=arm920t

make sure target ip address is according to thread_io/client.h:

#define HOST1 "192.168.42.145"	// TS-7800 with 2 IO cards used for Truck_Project
#define HOST2 "192.168.42.146"	// TS-7800 with just one IO card (for now)
#define Host3 "192.168.42.148"	// TS-7200 with 2 IO cards
#define Host_Sim "192.168.42.110"	// simulated host on linux box

and edit thread_io/ncurses/demo_menus2.c so init_client(HOSTx)
calls the right HOSTx

if using the make file for the simulator: thread_io/linux_make, 
make sure Host_Sim define in client.h is set to the ip address 
of the right linux box that the sched simulator is running on

A 4x4 keypad is attached to the PIC24 so when a key is pressed, one of the 
following bytes is decoded:

0xE0 - '#'
0xE1 - '*'
0xE2 - '0'
0xE3 - '1'
0xE4 - '2'
0xE5 - '3'
0xE6 - '4'
0xE7 - '5'
0xE8 - '6'
0xE9 - '7'
0xEA - '8'
0xEB - '9'
0xEC - 'A'
0xED - 'B'
0xEE - 'C'
0xEF - 'D'

(Alternatively, the PIC can get the keypresses from one of the comm ports and double
as the keypad)

keypad layout - since the six reassignable keys are on the outside (bottom and left) it makes
sense to use these as special function keys.

1 2 3 A
4 5 6 B
7 8 9 C
* 0 # D

dec		hex		char
35		23		#
42		2a		*
48		30		0
49		31		1
50		32		2
51		33		3
52		34		4
53		35		5
54		36		6
55		37		7
56		38		8
57		39		9
65		41		A
66		42		B
67		43		C
68		44		D

				
The TS-7200 uses comm1 as a monitor but can be disabled and used as an extra serial port
as long as the sched program can start automatically. Since I really don't need an extra
serial port on the TS-7200 I can just have a DB9 connector wired out to the dashboard
and possibly a switch attached to the jumper on the TS-7200 board which disabled comm1
used as a monitor. The TS-7200 uses the ethernet connector as a TCP/IP server so a linux
box running the client program (/dev/thread_io/ncurses) can be hooked up and and the 
client can log on and off at anytime.

So currently there is an extra serial port available on the FPGA and one extra on the
TS-7200.

The dashboard will have a DB9 connector for the TS-7200 monitor and one for the FPGA
plus a RJ-45 connector to the TS-7200 ethernet port. (Use a crossover ethernet cable
from the linux laptop to the RJ-45 jack - or use a old D-link router as hub in case
for another client to log into the TS-7200).

The dashboard will have programming connectors for:
1) the PIC24 - 6 pin din
2) 14 pin ICD connector to program the FPGA

The TS-7200 has a reset button on board and can be re-wired to bring it out to the
dashboard.

So the 2 DB9 connectors, the 3 programming jacks, the RJ-45 jack, the reset buttons
and the on/off switches can be in a panel with a cover so it can be opened only for
upgrading, testing and debugging.

FPGA connections:

1) 2 inputs for the mph & rpm and alternately, another rpm for the optional
		missing tooth wheel.
2) a tone-generator output which goes to a speaker.
3) an output which breaks the circuit to the fuel pump.
4) other optional IO for future expansion.

The inputs to the FPGA should have 5v clamping diodes which go to a 5v-3v3 converter.

PIC24 connections:

1) 8 or 16 inputs for the ADC (eng temp & oil pressure to start with)
2) other IO for future expansion.

The TS-7200 has connectors for the I/O (PC-104 card) - inputs from external switches or
momentary contact push-buttons - outputs go either directly to lights 
(dash indicator lights) or to high-amp relays (headlights, starter relay, etc)

TS-7200:
2 UARTs are RS-232 - 1 goes to PIC24, the other is open
The ehternet is for a monitor (use cross-over cable to laptop)

PIC24:
1 UART goes to TS-7XXX (5-3v3 conv to RS-232 conv)
SPI goes to FPGA (4k7 pull-up resistors)

FPGA:
1 UART goes to monitor (5-3v3 conv to RS-232 conv)

"make set_eeprom_save_fuse" to set fuses so eeprom is saved when reprogramming
"make clear_eeprom_save_fuse" to set fuses so eeprom gets erased everytime

(10/13/17)
TS-7800:
Has 3 UARTS, faster CPU & better OS. Memory access is diff for DIO/LCD & PC104.
No built-in SPI like the TS-7200 but very little docs on the Marvell processor. 
(would be nice to have interrupt routine that handles the SPI which the pins could be
on the DIO. Since the TS-7800 is in a remote box we have to use serial anyway).

(10/25/17)
added 2 branches: TS-7200 & TS-7800 but made changes in master so the Makefile in
thread_io can be changed to compile for either one. (search for "-DTS-7800")
also need to change the init_client(HOSTn) in demo_menus2.c and client.c in ncurses
according to the defines in client.h: 

#define HOST1 "192.168.42.145"	// TS-7800 with 2 IO cards used for Truck_Project
#define HOST2 "192.168.42.146"	// TS-7800 with just one IO card (for now)
#define Host3 "192.168.42.148"	// TS-7200 with 2 IO cards

Don't use the functon pointer array in the thread_io, just have dedicated threads
and have the serial port one with the highest priority.

Order another 2GB SD card for the TS-7800 to back up OS on.

Get all the ssh's to use keygen instead of passwords

Add extra behavoir info to the I_DATA struct:

typedef struct o_data
{
	char label[20];
	UCHAR port;
	UCHAR onoff;			// 1 of on; 0 if off
	UCHAR type;
	UINT time_delay;
	UCHAR pulse_time;
} O_DATA;

typedef struct i_data
{
	char label[ILABELSIZE];
	UCHAR port;
	UCHAR affected_output;
	UINT temp;
} I_DATA;

type:
0) regular - on/off state doesn't change until user tells it to
1) on for time delay seconds and then it goes back off
2) goes on/off at a pulse_time rate until turned off again
4) goes on/off at pulse_time rate for time_delay seconds and then back off
5) toggle switch realized in momentary push-buton: push & release of a 
	momentary push-button turns bit on or off

1 task scans all the outputs using ollist_find_data and if type != 0 && onoff == 1 then
read last_time_state_changed (UINT) in current O_DATA and check against current time using localtime
in this case onoff == 1 means its active 


10/16/17
made separate make files (make_db) to compile init_db & list_db on both host and target side
/thread_io (target) - sched
/thread_io/ncurses (host) - client

did away with curr_i_array & curr_o_array and just used the ill & oll linked lists
menus:
1) Host
	("Open"),						  // 0
	("Save File"),					  // 1
	("Edit idata"),					  // 2
	("Edit odata"),					  // 3
	("Exit"),						  // 4
	("Shift Left"),					  // 5
	("Shift Right"),				  // 6

2) Target
	("Open"),						  // 0
	("Save File"),					  // 1
	("Save As"),					  // 2
	("Delete"),						  // 3
	("List idata"),					  // 4
	("List odata"),					  // 5
	("Send idata"),					  // 6
	("Send odata"),					  // 7
	("Show All"),					  // 8

3) Tool
	"Connect"),					// 0
	"Disconnect"),				// 1
	"Enable Start"),			// 3	close ckt to start relay for time delay x
										turn on fuel pump
										turn on fan after time delay y
	"On Fuel Pump"),			// 4
	"Off Fuel Pump"),			// 5
	"On Fan"),					// 6
	"Off Fan"),					// 7
	"Shutdown"),				// 8	turn of all
	"Clear Screen"),			// 9


got the following strange error:
	A clock IOB / clock component pair have been found that are not placed at an optimal clock IOB /
   clock site pair. The clock component <reset_IBUF_BUFG> is placed at site <BUFGMUX_X2Y0>. 
   The IO component <reset> is placed at site <IPAD119>.  This will not allow the use of the
   fast path between the IO and the Clock buffer. This is normally an ERROR but the 
   CLOCK_DEDICATED_ROUTE constraint was applied on COMP.PIN <reset.PAD> allowing your design
   to continue. This constraint disables all clock placer rules related to the specified COMP.PIN. 
   The use of this override is highly discouraged as it may lead to very poor timing results. 
   It is recommended that this error condition be corrected in the design.
then added the line:
NET "reset" CLOCK_DEDICATED_ROUTE = FALSE;
in the ucf file to turn it to a warning after trying for 3 days to fix it. Some kind of 
timing problem   

Need another database which has list of on-off times for each IO port. Have a field in
the O_DATA database which points to a on-off database (or text file).
In task2 when we check for a change in the inputs, check for a time-up in a list of
which active time-up array and then check the time of day to see if that port should
be turned on or off.

Use 12vdc->5vdc converter from separate motorcycle battery to power whole system.
Then have a way to keep the battery charged - either charge it from the car battery
or use solar panels (or switch between both)

**************** nice to have's: ****************

FPGA reads from missing tooth wheel for the crank position and calculates the amount
of necessary spark advance to control the distributor

Use the ts-bat3 battery backup on the stack.

TS-7800 has (2) SATA connectors for SSD drives. 

One of the TS-7200's have the PC104 pins going thru the bottom - we could put the bat3
on top of it and the other IO boards underneath which might be safer.

Find out how to get TS-7200 to use the pthreadlib in its lib dir so we don't have to
send it over as a static.

Instead of ncurses program running on laptop, just gen up a PHP web interface and use
the brower. (see dev2/TS-7260/www/)

make an extra field in the O_DATA and I_DATA structs called group for acting on a group

need a way to enter password (alnum stuff)

GPS and accel modules on FPGA (serial?)

cadmium sulfide photodetector under windshield for measuing light level to 
dim display to rpm/mph LED's and LCD screen automatically.

PWM signal from PIC24 controls SCR power to the LCD (to dim display)

LOAD_RAM needs the transmit/receiveByte calls

get alnum to work - just do it like the edit boxes only A->D is printed and
'*' is escape and '#' is 'enter'

do/init_exec has prompts but not part of check_boxes[]

any checkbox can apply to a 'group' IO

have a 100 or so byte section at beginning of dat files (just after the id tag) reserved
for comments that can be edited and viewed.

Use ESP8266 for remote wireless (bluetooth) control from Android phone (remote start
- alarm disable - door poppers)
