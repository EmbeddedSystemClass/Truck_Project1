Truck_Project1_notes.txt


PIC24 UARTS:

UART1 - RS232 to TS-7200
UART2 - AVR
UART3 - monitor

UART1 uses 3v3 -> 5v -> RS-232 -> serial port to TS-7200
UART2 uses 3v3 -> 5v -> serial port on AVR
UART3 uses 3v3 -> 5v -> RS-232 -> serial port to monitor

There is an SPI bus from the PIC24 to the FPGA: FPGA is master while PIC24 is slave.
SPI from FPGA (master) to AVR (slave)
(or) just one bus using (2) SS signals

SPI signals from FPGA to PIC24 just need a 4k7 pull-up resistor
SPI signals from FPGA to AVR need a 5<->3v3 converter (with pull-ups?)

FPGA to AVR works up to ~30K doing just an echo

//******************************************************************************************//
//************************************* PIC24_support **************************************//
//******************************************************************************************//

Truck_App2.c is the main module that runs on the PIC24FJ128GB110 chip.
It uses the ESOS library. Each ESOS_USER_TASK will run independently.
Each task must be registered in user_init.

Basically, the  PIC24FJ128GB110 will route message traffic to and from the FPGA, the TS-7200
and the LCD screen. The AVR chip is the driver for the LCD screen and just gets commands from
the PIC24FJ128GB110 over the serial port. The path to the FPGA is the SPI and the path to the
AVR and the TS-7200 are serial ports. The keypad input manages the menuing of the LCD screen
and can display optional real time info like engine speed, engine temp, oil pressure, etc.
There will also be a task to read the ADC's which measure temp sensors and the oil pressure.
The FPGA has 2 serial ports (transmit only) that send rpm & mph data to a couple of off-the-
shelf 4 digit LED's that will be on the dashboard. The FPGA also sends the rpm & mph data to
the PIC24FJ128GB110 via the SPI (as master).
Other telemetry data can be added later like distributor timing to use for spark advance.
The TS-7200 has a removable (not hot-swapable) compact flash disk so the idea is to have a 
'black box' FDR that records the last so many hours or minutes of the telemetry data to a
file that can be downloaded later.
	
// skeleton example of 2 tasks - test1 task sends mail to cmd_param task

ESOS_USER_TASK(cmd_param);
ESOS_USER_TASK(test1);
...
ESOS_USER_TASK(cmd_param)
{
    static uint16_t data;
    
    ESOS_TASK_BEGIN();

    while(TRUE)
    {
        ESOS_TASK_WAIT_FOR_MAIL();
        while(ESOS_TASK_IVE_GOT_MAIL())
        {
			// this can also be 8 bytes
            data = __esos_CB_ReadUINT16(__pstSelf->pst_Mailbox->pst_CBuffer);
			// do something with data
        }
    }
    ESOS_TASK_END();
}

ESOS_USER_TASK(test1)
{
    static ESOS_TASK_HANDLE cmd_param_task;
    static uint16_t _cmd_param = 0;
    
    ESOS_TASK_BEGIN();
    cmd_param_task = esos_GetTaskHandle(cmd_param);

    while(TRUE)
    {
		// set _cmd_param to something
		__esos_CB_WriteUINT16(cmd_param_task->pst_Mailbox->pst_CBuffer,_cmd_param);
		ESOS_TASK_WAIT_TICKS(2000);
	}
    ESOS_TASK_END();
}	
void user_init(void) 
{
	...
    esos_RegisterTask(test1);
    esos_RegisterTask(cmd_param);
	...
}

// skeleton example of 2 tasks using a semaphore 

ESOS_USER_TASK(task1);
ESOS_USER_TASK(task2);
ESOS_SEMAPHORE(sem1);

#define MY_DELAY 100

ESOS_USER_TASK(task1)
{
    ESOS_TASK_BEGIN();

    while(TRUE)
    {
        ESOS_SIGNAL_SEMAPHORE(sem1,1);	// send signal task2 to continue
        ESOS_TASK_WAIT_TICKS(MY_DELAY);
    }
    ESOS_TASK_END();
}

ESOS_USER_TASK(task2)
{
    ESOS_TASK_BEGIN();
    while(TRUE)
    {
        ESOS_TASK_WAIT_SEMAPHORE(sem1,1);	// wait here until task1 sends a signal to continue
        ESOS_TASK_WAIT_TICKS(MY_DELAY/2);	// even though the delay here is shorter it will effectively
											// be the same as the delay time of task1
											// if the param is 2 instead of 1 it will wait for 2 signals
											// from task1
    }
    ESOS_TASK_END();
}

void user_init(void) 
{
	...
    ESOS_INIT_SEMAPHORE(sem1,0);
    esos_RegisterTask(task1);
    esos_RegisterTask(task2);
	...
} // end user_init()

// skeleton example of waiting on chars from comm3 and sending to comm2 and comm 1

ESOS_USER_TASK(serial_port1)
{
	static uint8_t data;
    ESOS_TASK_BEGIN();
    while(TRUE)
	{
        ESOS_TASK_WAIT_ON_AVAILABLE_IN_COMM3();
        ESOS_TASK_WAIT_ON_GET_UINT83(data);
        ESOS_TASK_SIGNAL_AVAILABLE_IN_COMM3();

        ESOS_TASK_WAIT_ON_AVAILABLE_OUT_COMM();
        ESOS_TASK_WAIT_ON_SEND_STRING("Here's the data byte: ");
        ESOS_TASK_WAIT_ON_SEND_UINT8_AS_HEX_STRING(data);
        ESOS_TASK_WAIT_ON_SEND_UINT8(0x20);			// print a space character
        ESOS_TASK_WAIT_ON_SEND_STRING("/n/r");		// print a carriage return
        ESOS_TASK_SIGNAL_AVAILABLE_OUT_COMM();		// (what is a carriage anyway?)
		
        ESOS_TASK_WAIT_ON_AVAILABLE_OUT_COMM2();
        ESOS_TASK_WAIT_ON_SEND_UINT8_AS_HEX_STRING2(data);
        ESOS_TASK_SIGNAL_AVAILABLE_OUT_COMM2();
	}
	ESOS_END_TASK();
}

// timers
// using the ESOS_USER_TIMER the fastest possible f is 500Hz (2ms)
// and using the ESOS_WAIT_TICKS(1) = 250Hz (4ms)

ESOS_USER_TASK(test_RE7)
{
    static  uint8_t data = 2;
    CONFIG_RE7_AS_DIG_OUTPUT();
    ESOS_TASK_BEGIN();
    while(1)
    {
	    ESOS_TASK_WAIT_TICKS(1);
	    _LATE7 = ~_LATE7;
    } // endof while()
    ESOS_TASK_END();
}

ESOS_USER_TIMER(testTimer)
{
    _LATG15 = ~_LATG15;
}

void user_init(void)
{
    CONFIG_RG15_AS_DIG_OUTPUT();
	esos_RegisterTimer( testTimer, 1);
	esos_RegisterTask(test_RE7);
}

//******************************************************************************************//
//*************************************** AVR_t6963 ****************************************//
//******************************************************************************************//

The AVR is just a driver for the LCD display. The serial port of the AVR communicates with a PIC24.
The PIC24 sends a stream of data specified by an array of structs rt_params.

(main.h)
typedef struct rt_params
{
	UCHAR row;			// row, col tells where the param will appear on screen
	UCHAR col;
	UCHAR shown;		// if its shown or not
	UCHAR dtype;		// 0 = UCHAR; 1 = UINT; 2 = dword?
	UCHAR type;			// rt_types
} RT_PARAM;

A 4x4 keypad is attached to the PIC24 so when a key is pressed, one of the 
following bytes is sent to the AVR

0xE0 - '#'
0xE1 - '*'
0xE2 - '0'
0xE3 - '1'
0xE4 - '2'
0xE5 - '3'
0xE6 - '4'
0xE7 - '5'
0xE8 - '6'
0xE9 - '7'
0xEA - '8'
0xEB - '9'
0xEC - 'A'
0xED - 'B'
0xEE - 'C'
0xEF - 'D'

(Alternatively, the PIC can get the keypresses from one of the comm ports and double
as the keypad)

When the PIC24 sends a byte in the range of 0xE0 -> 0xEF that will be interpreted as
a keypress. The dialog will filter this out using a switch statement. The default will
just return whatever was passed in. (see get_key() in menus.c)

The section of code at the beginning of main.c reads from the eeprom 3 different arrays:
1) labels
2) rt_params
3) menu_structs
It also reads how many labels, rt_params and menu structs and their offsets into the eeprom.

// the pic gets the key, exec's the fptr from the current menu_structs, and sends the data
// the avr gets the data,
// exec's the fptr based on the key sent,
// the AVR should call the init before the fptr

key --> PIC
		fptr(key)
		(send menu_index and all the menus[]
		in the current menu_struct) -------------->		AVR
														(receive same menu_index...)
														fptr(key)

the fptr's will exec all the func's in the fptr[] array of function pointers:

(*fptr[NUM_FPTS])(UCHAR) = { menu_change, do_exec, do_chkbox, non_func, do_numentry, do_init };

which are the same func names on both sides but they each do diff. stuff...
so based on the keypress, both should exec the same func.
sending the data in between each fptr being exec'd, will just set the menu_index and
the rest of the menus[] in the current menu_struct. The AVR gets the curr_menu_index
so when display_menus is called it does a get_mlabel for each of the curr_menus[] sent
as the current menu_struct so it can display the current menu. The get_mlabel just
looks up the menu strings from eeprom. The strings for the chkbox labels are stored in
ram and must be sent beforehand by the LOAD_RAM cmd.

so before the fptr in the AVR is called when a memu with a diff fptr
(menu_change, do_chkbox, do_exec or do_numentry) it must redraw the
display and if do_chkbox or do_exec, put up the current check box strings
so we need to know when the AVR's fptr is called, call the init_ func for
each do_ckbox, do_exec & do_numentry.

PIC:
<get keypress and call generic...>


static UCHAR generic_menu_function(UCHAR ch)
{
	ret_char = (*fptr[menu_structs[get_curr_menu()].fptr])(ch);

	// do all the sending including the keypress

	return ch:
}

AVR:
static UCHAR generic_menu_function(UCHAR ch)
{

	// do all the receiving except the keypress (passed in as ch)

		ret_char = (*fptr[tfptr])(ch);		// execute the function pointer from the PIC
		display_menus();
		if(prev_menu_index != curr_menu_index && ret_char != KP_AST)
		{
			switch (prev_menu_index)
			{
				case MAIN:
				case MENU1A:
				case MENU1B:
				mvwprintw(win, LAST_ROW-8,1,"case 1");
				break;
				case MENU1C:
				case MENU1D:
				case MENU1E:
				do_chkbox(ret_char);
//				do_exec(ret_char);
				mvwprintw(win, LAST_ROW-8,1,"case 2");
				break;
				case MENU2A:
				case MENU2B:
				do_exec(ret_char);
//				do_chkbox(ret_char);
				mvwprintw(win, LAST_ROW-8,1,"case 3");
				break;
				case MENU2C:
				case MENU2D:
				case MENU2E:
				case MENU3A:
				case MENU3B:
				do_numentry(ret_char);
				mvwprintw(win, LAST_ROW-8,1,"case 4");
				break;
				default:
				break;
			}
		}
		prev_menu_index = curr_menu_index;
		prev_ret_char = ret_char;
	}
	return ret_char;
}


the user task poll_keypad calls get_key in PIC_menu.c with only the raw keypress and the
get_key in PIC_menu.c sets an array of UCHARs to pass back out to the esos task that sends them
to the AVR (9/16/17) no that's not what I ended up doing.

the main.c in the AVR calls get_key in AVR_menu.c

The generic_menu_func in PIC gets the keypress, passes it to the func ptr. If the menu_change fptr
is called then it sets the new set of menus. Then in generic we send the fptr, ch, array of menus
and aux_string then it exits and waits for another keypress.

In AVR the generic reads the fptr, ch, menu array and aux_string, then exec's the function ptr,
displays the new menus and returns to wait for another read. 

To change/add menus, add the menu type to main.h in the menu_types enum, then make sure the
update_menu_labels calls in burn_eeprom() in sim_write.c match. Also make sure that
NUM_MENUS in pic_main.h matches the number of calls of update_menu_structs() in sim_write.c
Then add the new menu type in the case statement in set_list - this is essentially the
initialization for the menu on the sim_write side (PIC). 
Then on the sim_read side (AVR), add the menu type in the case statement in generic_menu_function
in AVR_menu.c where there is an if(prev_menu_index != menu_index).
This is where the initialization occurs on the AVR when a new menu is started. 
However, the menu_index is the last param in the call to update_menu_structs (or the index elem
in MENU_FUNC_STRUCT.

If the ret_key returned from get_key() call in Truck_App.h is one of the NF_x codes from the non_func
then we can do something like not send as many bytes in the loop in comm2_task or send some extra
stuff to the AVR with a special cmd that's filtered by the get_key function int PIC_menu.c like
read some extra data or do a reset or some init function. Very cool stuff!

9/18/17 - tested the PIC24 sending data to gcc compiled test_read/write & rw2 and had
all kinds of strange problems. The PIC24 reads and writes data ok using just test_read/write
but test_rw1/2 do strange things. Put the sim_read on 110 and got it to work upto the 
point of entering numbers. Need to init the labels and rt_params in 'eeprom_sim' using
the BURN_PART commands of the PIC24. Since we don't need the labels in the AVR we don't
need to send over the menu_structs. Use the avr_send_data in PIC24 to init the rest of the
eeprom_sim.

The prompt strings for the checkboxes and execs will have to be pumped over whether
using the sim or the AVR. This happens when doing an init_checkboxes or init_execchoices

The checkboxes are not mutually exclusive, the exec_choices are, so we need labels
for all but the check_boxes need only cover the number of check_boxes for do/init_checkboxes
The execs only cause an event on either/both the PIC & AVR. (could have an array of fptr's
for just the exec_choices)

new idea for display checkbox/exec prompts:
send over the size of each array of prompts just after the menu_indexes (menus[])
if the choice is starting a new checkbox/exec - this will eliminate all the checkbox labels
being stored in ram and doing a lookup everytime for the label.

first send the high/low_byte of the total data to send,

then send the number of prompts to display (byte)
then send an array of indexes into the prompt string (array of bytes)

then send the prompt string (array of chars)

(receive using minicom on 192.168.42.115 won't receive but ~/dev/test_read.c does ???)
no! 192.168.42.110 won't transmit in minicom until you exit.

decided not to do this for now:
{
	When the Truck_App starts one of the tasks is get_sync.
	It will send to comm2 a sequence of: "0x55, 0x55, 0x55, 0xAA, 0xAA, 0xAA"
	assuming the AVR (or sim_read) has the syncup byte set to 0, it will
	read the sequence and set the syncup byte to 1 and the done to 1.
	Then it will send a sequence of "0x51, 0x52, 0xA1, 0xA2" back to the 
	PIC24. Then the get_sync task will wait for the correct sequence to be
	sent back and wake up the comm2_task which is waiting for the
	get_comm2 task to wake up which put itself to sleep when it started up.
	Then get_sync will put itself to sleep. 

	the read() call in the loop in main of sim_read.c for the
	simulator is the same as the receiveByte() call in the 
	loop of main.c for the AVR. So when the read() gets a char
	it can call a function that checks to see if 
}


currently the ESOS stuff is doing weird shit - prolly need caps
went back to sim_write->sim_read and ended up pushing the entire eeprom 
data along with TOTAL_NUM_CHECKBOXES of the checkboxes arrays.

test_write_data:

The subdirectory called test_write_data has 2 separate makefiles to compile the sim_read and
sim_write:

make -f make_avr - compiles the sim_read
make -f make_pic - compiles the sim_write

4 possible conditions:

1) sim_write->AVR			- testing the simulator with actual AVR
2) PIC->sim_read			- testing the simulator with actual PIC
3) PIC->AVR					- actual PIC->AVR
4) sim_write->sim_read		- using null-modem cable with 2 simulators

1) 'LOAD_RAM' sends over the the cblabels[], the checkboxes and rt_params[]
2) 'LOAD_RAM' sends over the eeprom image, the cblabels[], the checkboxes and rt_params[]
3) 'LOAD_RAM' sends over the the cblabels[], the checkboxes and rt_params[]
4) 'LOAD_RAM' sends over the eeprom image, the cblabels[], the checkboxes and rt_params[]

in all case LOAD_RAM sends over everything except eeprom image when sending to AVR

in all cases update_ram() which calls update_menu_structs must be run in either 
the PIC or sim_write to setup the menu_structs array

update_rtparams currently is sent over in LOAD_RAM but since its now burned into eeprom
we can do a lookup in the AVR using read_eeprom



(when testing sim_write -> AVR set the DISABLE_LCD define in make_avr and the TESTING_AVR
	define in make_pic)

if compiling the AVR then MAIN_C is defined	

AVR_menu.c	- runs in AVR
PIC_menu.c	- in PIC24

domake1 script runs the make_pic makefile and if there are no errors, calls copy1.sh which
tars up all the necessaray files to compile sim_write and scp copies them to the linux box
used to run the sim_write (currently 192.168.42.110)

domake2 script runs the make_avr makefile and if there are no errors, calls the copy2.sh which
tars up all the files and copies them to the linux box to run the sim_read (currently 192.168.42.115)

each linux box has a script called extract.sh which un-tars the tar file sent over and compiles
everything and starts up the sim_read/write. The sim_read must be started first since it waits
on a read() to start reading the eeprom image which is sent over as soon as the sim_write starts.

Currently we must, just after the eeprom image is sent over, hit the 'r' key on the sim_write 
which does a LOAD_RAM command which sends over all the checkbox prompts (cblabels array),
current state of the checkboxes (checked or not), the indexes for the checkboxes, the
rt_params array of structs, and the sample_numbers array for the edit boxes.

keypad layout - since the six reassignable keys are on the outside (bottom and left) it makes
sense to use these as special function keys.
1 2 3 A
4 5 6 B
7 8 9 C
* 0 # D

The MENU_FUNC_STRUCT's is an array of the following struct type:

typedef struct menu_func
{
	UCHAR fptr;								// which function to call (menu_types)
	int menus[6];							// which menu to goto if _menu_change is the fptr
	UCHAR index;
} MENU_FUNC_STRUCT;

MENU_FUNC_STRUCT menu_structs[NUM_MENUS];

Here's a partial list of what the array of structs are loaded with:

	fptr		menus[0]--->    							  menus[5] index

_menu_change, 	MENU2C, MENU2D, MENU2E,   MENU3A, MENU3B, MENU1C, MAIN		(main)
_menu_change,	MENU2B, MENU2C, MENU2D,   MENU2E, MENU3A, MENU3B, MENU1A	(MENU1A)
_menu_change,	MAIN,   MENU2D, MENU1B,   MENU1D, MENU2A, MENU2B, MENU1B	(MENU1B)
_do_chkbox,		ckup,   ckdown, cktoggle, ckenter, ckesc, cclear, MENU1C	(MENU1C)
_do_chkbox,		ckup,   ckdown, cktoggle, ckenter, ckesc, cclear, MENU1D	(MENU1D)


When the system starts, the first menu_struct will be loaded as the current menu.
the menus[] is an array of 6 ints which are indexes (defined by enum menu_types 
in main.h) into the list of labels in the eeprom. When the PIC gets a key to change
menus it will send it over along with the menu index and also the list of menus.

redefined keys for each menu choice) into an array. The 6 redefinable keys are
'A'
'B'
'C'
'D'
'#'
'0'

 If the fptr is 0, then 
look up the menu specified by the menu element and just go to that menu. The function assigned 
to '*' in generic_menu_function() will always go back to the previous menu. 

This way, we have 3 possible choices:
1) Use the 'factory default' set of menus in eeprom.
2) Dynamically load another set of menus using a special command from the PIC24.
3) #2 plus burn the new menu set into eeprom.


	
The array of structs will just be enough to display on the screen (or there could be more if
the scrolling function can move the choices in and out)

menu choices for checkboxes:
A - up
B - down
C - set/clear
D - enter

when using the simulation (test_write_data) the data is sent in aux_data AUX_DATA_SIZE
bytes at a time because of the fact that the serial port is set to non-blocking, there's
a problem sending a variable number of bytes at a time so when it comes time to use it
on the actual hardware, some things may have to be changed...

keypad layout:

1 2 3 A
4 5 6 B
7 8 9 C
* 0 # D

dec		hex		char
35		23		#
42		2a		*
48		30		0
49		31		1
50		32		2
51		33		3
52		34		4
53		35		5
54		36		6
55		37		7
56		38		8
57		39		9
65		41		A
66		42		B
67		43		C
68		44		D

test_write_data (read) - simulates the AVR
test_write_data (write) - simulates the PIC24


FPGA UART2 <->  PIC24 comm2
				PIC24 comm3 <-> AVR
				PIC24 comm1 <-> TS-7200 comm2
				
The TS-7200 uses comm1 as a monitor but can be disabled and used as an extra serial port
as long as the sched program can start automatically. Since I really don't need an extra
serial port on the TS-7200 I can just have a DB9 connector wired out to the dashboard
and possibly a switch attached to the jumper on the TS-7200 board which disabled comm1
used as a monitor. The TS-7200 uses the ethernet connector as a TCP/IP server so a linux
box running the client program (/dev/thread_io/ncurses) can be hooked up and and the 
client can log on and off at anytime.

So currently there is an extra serial port available on the FPGA and one extra on the
TS-7200.

The dashboard will have a DB9 connector for the TS-7200 monitor and one for the FPGA
plus a RJ-45 connector to the TS-7200 ethernet port. (Use a crossover ethernet cable
from the linux laptop to the RJ-45 jack).

The dashboard will have programming connectors for:
1) the PIC24 - 6 pin din
2) the AVR - USB connector to the buspirate board *
3) 14 pin ICD connector to program the FPGA
* or if we want to use the SPI then the MISO, MOSI, etc could have a disconnect

The TS-7200 has a reset button on board and can be re-wired to bring it out to the
dashboard. The PIC24 and the AVR can have separate switches to turn each board on
and off. 

So the 2 DB9 connectors, the 3 programming jacks, the RJ-45 jack, the reset buttons
and the on/off switches can be in a panel with a cover so it can be opened only for
upgrading, testing and debugging.

FPGA connections:

1) 2 inputs for the mph & rpm and alternately another rpm for the optional
		missing tooth wheel.
2) a tone-generator output which goes to a speaker.
3) an output which breaks the circuit to the fuel pump.
4) other optional IO for future expansion.

PIC24 connections:

1) 8 or 16 inputs for the ADC (eng temp & oil pressure to start with)
2) other IO for future expansion.

The TS-7200 has connectors for the I/O - inputs from external switches or
momentary contact push-buttons - outputs go either directly to
lights (dash indicator lights) or to high-amp relays (headlights, starter relay, etc)

TS-7200:
2 UARTs are RS-232 - 1 goes to PIC24, the other is open
The ehternet is for a monitor (use cross-over cable to laptop)

PIC24:
1 UART goes to PIC24 (5-3v3 conv to RS-232 conv)
another UART goes to AVR (5-3v3 conv)
SPI goes to FPGA (4k7 pull-up resistors)

FPGA:
1 UART goes to monitor (5-3v3 conv to RS-232 conv)

"make set_eeprom_save_fuse" to set fuses so eeprom is saved when reprogramming
"make clear_eeprom_save_fuse" to set fuses so eeprom gets erased everytime

