Truck_Project1_notes.txt

Truck_Project1 is an automotive SCADA system which uses a Xilinx Spartan-3E to 
monitor real-time data, a PIC24FJ128GB110 to handle a keypad and route message
traffic, a ATMEGA328P to drive a t6963 LCD screen, and a TS-7200/7800 to do
I/O (turning on and off lights and reading switches).


  												| AVR |===> t6963 LCD screen
  												  ^
  												  | RS-232
----|											  |							Laptop (optional)
	|											  |							    ^
F	|											  |								|
P	|											  v								|TCP/IP
G	|---------------> RS-232 ------------------>| P	|							|
A	|											| I	|							v
	|						|-----------|		| C |						|-----------|
----|						|			|		| 2	|						|			|	
							|  keypad	|======>| 4 |<------ RS-232 ------->| TS-7800	|
							|			|									|			|
							|-----------|									|-----------|

the PIC24FJ128GB110 (PIC) will route message traffic to and from the FPGA, the 
TS-7200 and the LCD screen.

The menuing of the LCD screen and can display optional real time info like engine speed,
engine temp, oil pressure etc coming directly from the FPGA.

There will also be a task to read the ADC's which measure temp sensors and the oil pressure
(among other things like the photodiode behind the windshield).
The FPGA has 2 serial ports (transmit only) that send rpm & mph data to a couple of off-the-
shelf 4 digit LED's that will be on the dashboard. The FPGA also sends the rpm & mph data to
the PIC via the serial port.

Other telemetry data can be added later like distributor timing to use for spark advance.

directories:
PIC24_support - source and libs for PIC24FJ128GB110 (uses MPLAB X)
AVR_t6963 - ATMEGA328p source and support files (uses avrdude)
thread_io - source for the TS-7200/7800 cards (from Technologic Systems)
thread_io/ncurses - source for the ncurses program that runs on the laptop and communicates
						with the TS-7200/7800.
Truck_App1 - source for the FPGA (Xilinx Spartan-3E) in VHDL

The PIC24 uses a really nice RTOS called ESOS which is from people at Mississippi State.
(see https://sites.google.com/site/pic24micro//Home/Course)
within the PIC24_support directory there is /lib and /esos. lib is the src & include
for using a PIC24 (or most other 16-bit controllers from Microchip*) while the esos
directory is the RTOS which uses some of the /lib directory files. There is a file in
the PIC24_support directory called esos_examples.c that explains how to use the ESOS system.

The thread_io directory has files used to compile an embedded linux program that uses
the POSIX pthread library to handle serial io and tcp/ip traffic and drive a io card that
plugs into the TS-7XXX PC-104 bus. I bought the cards used on ebay. They are made by
Tri-M Engineering. Each card has 20 inputs and 20 outputs. The outputs are small 5A relays
onboard the card. The cards can be set to access different memory/io addresses so up
to 4 can be stacked on each other. I've tried just about every free RTOS out there and
no-one seems to have the ports to work on the TS-7200 which use the ARM920T processor with
the EP9301 chipset. I like the uCOS-II Jean J. Labrosse of Micrium, Weston, FL and he has
the port files for the ARM processor but I wasn't inclined to take a year-long self-course
on ARM assembly language, linux internals and the ARM architecture, although I did 'hack'
through it for a while. So using the POSIX pthreads are a pretty good alternative and you
can learn more about pthreads from 'Pthreads Programming' by Dick Buttlar from O'Reilly.

The Truck_App1 directory has all the files for compiling (if you want to call it that)
a Spartan-3E FPGA from Xilinx. The files ending in .vhd are the VHDL programming language
and I used a free copy of ISE from Xilinx. Actually, I tried to download it from the 
Xilinx website recently and its not exactly free since now you have to have a verifiable
company and phone no. so I'm using a free copy I downloaded a couple years ago. The
particular board running this is called an XC3S500E which only has the Spartan-3E chip,
the clock and the pinout connectors for no less that 200 io pins. These can be purchased
on ebay for about $35USD. All the other development boards have all the buttons, LEDs,
DB connectors and USB ports which I didn't need. The only problem with the io connectors
with these is that they are not the standard 1mm pitch that fits nicely into most
perfboards which is what I'm using since I'm not into making my own printed circuit
boards. If you can find a copy of ISE from Xilinx, it also comes with a simulator called
ISim which lets you see how your VHDL program works and is really useful for testing
and debugging the FPGA. The other alternative to Xilinx would be Altera which is probably
geared more towards the hobbiest, I would think, but I'm too far down the rabbit hole
now. If you want a copy of ISE, email me at hwswhacker1256@gmail.com and I'll see if
I can get the file to you via ftp or something.

You can learn more about VHDL and FPGA by doing a google search but here's the executive
summary: 

With most modern micropressors and microcontrollers you write a program in C/C++ or
whatever, compile it to a binary file, load it to the processor memory and the hardware
on the chip executes each instruction from the binary file step by step. With the FPGA
(Field Programmable Gate Array) the VHDL code lets you build the hardware or the
processor core. In other words, the ISE development system actually routes the 
connections on the chip so you can have parallel processes running completely
independent of each other in real time. This is really powerful when doing high speed
data aquisition but its a steep learning curve. The ISim (simulator) is really helpful 
and I took most of my code from the examples from the book 'FPGA Prototyping by VHDL 
example' by Pong. P. Chu. 

The thread_io/ncurses directory has all the source and support files for compiling a
linux program that runs on any linux desktop and uses ncurses to communicate over a
tcp/ip connection to the TS-7200/7800 box. The program running on the TS-7XXX box
opens a couple binary files ending in .dat which are a data base where each record is
a configuration for each of the 20 io ports. The dat files starting with an 'o' are
for the the 20 output ports and the dat files starting with an 'i' are for the 20
input ports. Basically, when there is a change on one of the inputs, it can effect
any one of the 20 outputs. So that way you can assign different outputs to inputs.
The ncurses program lets you change the configuration or load different dat files.
This can be kind of dicey for things like the starter motor so the ioport assigned
to the start switch only activates a relay that enables a button on the dash to close
the circuit the the actual starter solinoid. 

A 4x4 keypad is attached to the PIC24 so when a key is pressed, one of the 
following bytes is decoded:

0xE0 - '#'
0xE1 - '*'
0xE2 - '0'
0xE3 - '1'
0xE4 - '2'
0xE5 - '3'
0xE6 - '4'
0xE7 - '5'
0xE8 - '6'
0xE9 - '7'
0xEA - '8'
0xEB - '9'
0xEC - 'A'
0xED - 'B'
0xEE - 'C'
0xEF - 'D'

(Alternatively, the PIC can get the keypresses from one of the comm ports and double
as the keypad for testing)

keypad layout - since the six reassignable keys are on the outside (bottom and left) it makes
sense to use these as special function keys.

1 2 3 A
4 5 6 B
7 8 9 C
* 0 # D

dec		hex		char
35		23		#
42		2a		*
48		30		0
49		31		1
50		32		2
51		33		3
52		34		4
53		35		5
54		36		6
55		37		7
56		38		8
57		39		9
65		41		A
66		42		B
67		43		C
68		44		D

				
The TS-7200 uses comm1 as a monitor but can be disabled and used as an extra serial port
as long as the sched program can start automatically. Since I really don't need an extra
serial port on the TS-7200 I can just have a DB9 connector wired out to the dashboard
and possibly a switch attached to the jumper on the TS-7200 board which disabled comm1
used as a monitor. The TS-7200 uses the ethernet connector as a TCP/IP server so a linux
box running the client program (/dev/thread_io/ncurses) can be hooked up and and the 
client can log on and off at anytime.

So currently there is an extra serial port available on the FPGA and one extra on the
TS-7200.

FPGA connections:

1) 2 inputs for the mph & rpm and alternately, another rpm for the optional
		missing tooth wheel.
2) a tone-generator output which goes to a speaker.
3) an output which breaks the circuit to the fuel pump.
4) other optional IO for future expansion.

The inputs to the FPGA should have 5v clamping diodes which go to a 5v-3v3 converter.

PIC24 connections:

1) 8 or 16 inputs for the ADC (eng temp & oil pressure to start with)
2) other IO for future expansion.

The TS-7200 has connectors for the I/O (PC-104 card) - inputs from external switches or
momentary contact push-buttons - outputs go either directly to lights 
(dash indicator lights) or to high-amp relays (headlights, starter relay, etc)

TS-7200:
2 UARTs are RS-232 - 1 goes to PIC24, the other is open
The ehternet is for a monitor (use cross-over cable to laptop)

PIC24:
1 UART goes to TS-7XXX (5-3v3 conv to RS-232 conv)
SPI goes to FPGA (4k7 pull-up resistors)
(8-17-18) -can't get the SPI to AVR to work.

FPGA:
1 UART goes to monitor (5-3v3 conv to RS-232 conv)

"make set_eeprom_save_fuse" to set fuses so eeprom is saved when reprogramming
"make clear_eeprom_save_fuse" to set fuses so eeprom gets erased everytime

(10/13/17)
TS-7800:
Has 3 UARTS, faster CPU & better OS. Memory access is diff for DIO/LCD & PC104.
No built-in SPI like the TS-7200 but very little docs on the Marvell processor. 
(would be nice to have interrupt routine that handles the SPI which the pins could be
on the DIO. Since the TS-7800 is in a remote box we have to use serial anyway).

(10/25/17)
added 2 branches: TS-7200 & TS-7800 but made changes in master so the Makefile in
thread_io can be changed to compile for either one. (search for "-DTS-7800")
also need to change the init_client(HOSTn) in demo_menus2.c and client.c in ncurses
according to the defines in client.h: 

(4/29/18)
did away with all the menuing stuff in AVR which was a gigantic menuing system which was
supposed to be configurable. Long story short, the esos RTOS can't send mail messages
from regular functions, even when called from and esos task, nor can you call any
ESOS_TASK macros so now the menu choices and screen display will just have to be
hard-coded in for whatever is needed.

(9/4/18)
realized if I'm measuring the pulse of 1 plug wire, then I am getting a pulse for 
every 2 revolutions of the crankshaft. So since I couldn't figure out how to set
the RPM_DVND and RPM_CLOCK_COUNT in lib/Common.vhd, I just doubled the result value
in sensor.vhd returned from the averaging algoritm. 

Don't use the functon pointer array in the thread_io, just have dedicated threads
and have the serial port one with the highest priority.

Get all the ssh's to use keygen instead of passwords

got the following strange wtf error:
	A clock IOB / clock component pair have been found that are not placed at an optimal clock IOB /
   clock site pair. The clock component <reset_IBUF_BUFG> is placed at site <BUFGMUX_X2Y0>. 
   The IO component <reset> is placed at site <IPAD119>.  This will not allow the use of the
   fast path between the IO and the Clock buffer. This is normally an ERROR but the 
   CLOCK_DEDICATED_ROUTE constraint was applied on COMP.PIN <reset.PAD> allowing your design
   to continue. This constraint disables all clock placer rules related to the specified COMP.PIN. 
   The use of this override is highly discouraged as it may lead to very poor timing results. 
   It is recommended that this error condition be corrected in the design.
then added the line:
NET "reset" CLOCK_DEDICATED_ROUTE = FALSE;
in the ucf file to turn it to a warning after trying for 3 days to fix it. Some kind of 
timing problem...

when setting VHDL variables in the declaration statement like:
	"signal fubar: std_logic_vector(7 downto 0):= "00000000";"
and then trying to set the variable again in the reset section of the FSM, it will
use the value set in the reset section in the simulator, but when running the program
on the chip, it will use the value set in the declaration. Spent about 3-4 hours
on this one night.

can't call ESOS_TASK_WAIT_TICKS from within mail recipient?

note: don't do any assignment statements before ESOS_TASK_BEGIN()
it causes strange side-effects

**************** todo ****************

added fuel pump shutoff output for FPGA which shuts off fuel pump when rpms go to zero
this must be overridden to start (relay in series with relay controlled by io card)

also added rev limit feature which opens relay in series with io controlled relay for
ignition but might just want to have it set off an alarm - too much gas to carb to shut
off ignition possibly could wash out cylinders ?

use SS pin on 5-pin ICD between FPGA & PIC/AVR board to separate SPI signals from AVR/PIC.
The SPI signals on AVR are 5v so the FPGA SPI signals need to be converted from 3v3 to 5v
but the SPI signals on the PIC are 3v3 so we need a separate cable. It would be nice
to just use the ICD cable but even if we did converted the SPI signals from the ICD
to 3v3 for the PIC, there would be bus contention when programming the AVR because the
5-pin IDC is used by both the programmer and the SPI from the FPGA. So for now, just
use UART3 on PIC to talk to FPGA. In the next board version, have the signals from the
FPGA (master) going to the cable as 3v3 and just have the converter chip on the AVR
to convert it to 5v.
(8-17-18) -can't get the SPI to AVR to work.

Need another database which has list of on-off times for each IO port. Have a field in
the O_DATA database which points to a on-off database (or text file).
In task2 when we check for a change in the inputs, check for a time-up in a list of
which active time-up array and then check the time of day to see if that port should
be turned on or off.
(9-4-18) -this works for types 0-3

Use 12vdc->5vdc converter from separate motorcycle battery to power whole system.
Then have a way to keep the battery charged - either charge it from the car battery
or use solar panels (or switch between both)

sched needs a config file so it knows which dat files were used last instead
of just idata & odata which are loaded by default (see odometer.txt)

PIC24 in monster box will ask for user password before starting mtr. If seat switch
is opened (driver leaves seat) or if lock-out relay is energized (E-Stop button pushed)
then user will have to reenter password. So the IO box will send a message to the PIC24
telling it to go back to password mode. When password is entered, screen goes to normal
mode and msg is sent to IO box allowing the motor to start.

When E-Stop button is pushed and if lights are one, the lights will stay on for a preset
amount of time. 

If a button is not pushed within so many seconds the screen will dim and eventually go
dark. 

**************** nice to have's: ****************

use 2 extra pins from FPGA to 25 watt stereo amp using pwm2.vhd to play tunes

FPGA reads from missing tooth wheel for the crank position and calculates the amount
of necessary spark advance to control the distributor

Use the ts-bat3 battery backup on the stack.

TS-7800 has (2) SATA connectors for SSD drives. 

One of the TS-7200's have the PC104 pins going thru the bottom - we could put the bat3
on top of it and the other IO boards underneath which might be safer.

Find out how to get TS-7200 to use the pthreadlib in its lib dir so we don't have to
send it over as a static.

Instead of ncurses program running on laptop, just gen up a PHP web interface and use
the brower. (see dev2/TS-7260/www/) Yeah, right.

GPS and accel modules on FPGA (serial?)

cadmium sulfide photodetector under windshield for measuing light level to 
dim display to rpm/mph LED's and LCD screen automatically.

have a 100 or so byte section at beginning of dat files (just after the id tag) reserved
for comments that can be edited and viewed.

Use ESP8266 for remote wireless (bluetooth) control from Android phone (remote start
- alarm disable - door poppers)

SEN-12756 Sparkfun 3-Axis Accelerometer MMA8452
SEN-11931 Sparkfun Dig. Temp Sensor TMP102

