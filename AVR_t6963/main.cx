// dev/Atmel/SPI_test/main.c

// for programming AVR:
//first pin: 	10 SS		(not connected to buspirate)
//				11 MOSI		yellow clip
//				12 MISO		black regular clip
//				13 SCLK		other green clip
//				RST			whilte clip

// for running AVR:
//	GRN
//	YEL
//	BLK
//	RED

// this test sends ascii chars out on spi and prints out what's received
// FPGA reflects back what's received on spi and prints it out to 1st UART

#include <avr/io.h>
#include "../avr8-gnu-toolchain-linux_x86/avr/include/util/delay.h"
#include "sfr_helper.h"
#include <avr/eeprom.h>
#include <stdlib.h>
#include "USART.h"
//#include "spi.h"
#include "t6963.h"
#include "macros.h"
#include <string.h>
#include "main.h"
#include <stdio.h>
#include <stdlib.h>

//#define COLUMN              30      //Set column number to be e.g. 32 for 8x8 fonts, 2 pages
//#define ROWS                16

#define EEPROM_SIZE 1024
char eepromString[EEPROM_SIZE] EEMEM;

int main(void)
{
	int i,k,j;
	UCHAR test1, xbyte;
	UINT row,col;
	UCHAR ret_char = 0xFF;
	UCHAR eeprom_sim[EEPROM_SIZE];
	int loaded = 0;
	memset(eeprom_sim,0xFF,EEPROM_SIZE);
	size_t size = EEPROM_SIZE;
	int start_addr = 0;
	
	_delay_ms(100);
	initUSART();
	xbyte = 0x21;
	_delay_ms(100);

	GDispInit();
	_delay_us(10);
	GDispSetMode(XOR_MODE);
	_delay_us(10);
	GDispSetMode(TEXT_ON);
	_delay_us(10);
	GDispClrTxt();
	GDispStringAt(1,1,"LCD is on!");

    k = 0x41;
    row = 0;
    col = 0;
	row = col = 0;
	xbyte = 0x21;
	
	while(1)
	{
		GDispClrTxt();
		GDispStringAt(0,0,"waiting for input ...");
		xbyte = receiveByte();
		switch(xbyte)
		{
			case 'a':		// get eeprom image from host
				GDispStringAt(0,0,"get eeprom image from host");
				j = 0;
				for(i = 0;i < size;i++)
				{
					eeprom_sim[i] = receiveByte();
					j++;
				}
				transmitByte((UCHAR)j);
				transmitByte((UCHAR)(j>>8));
				transmitByte(ret_char);
				loaded = 1;
			break;

			case 'b':		// burn image to eeprom using update_byte
				GDispClrTxt();
				GDispStringAt(0,0,"burn image to eeprom");
				if(!loaded)
				{
					transmitByte(loaded);
					transmitByte(ret_char);
					transmitByte(ret_char);
				}else
				{
					j = 0;
					for(i = 0;i < size;i++)
					{
						eeprom_update_byte((uint8_t *)&eepromString[i], (uint8_t )eeprom_sim[i]);
						_delay_us(100);
						j++;
					}
					transmitByte((UCHAR)j);
					transmitByte((UCHAR)(j>>8));
					transmitByte(ret_char);
				}
			break;
			
			case 'c':		// burn image to eeprom using update_block
				if(!loaded)
				{
					transmitByte(loaded);
					transmitByte(ret_char);
				}else
				{
					// eeprom_update_block(src, dest, size)
					eeprom_update_block((const void*)eeprom_sim,(void *)(eepromString+start_addr),(size_t)size);
					transmitByte(ret_char);
					transmitByte(ret_char);
				}
			break;
			
			case 'd':		// display image on eeprom using read_block
				if(!loaded)
				{
					for(i = 0;i < size;i++)
						transmitByte(ret_char);
						
					transmitByte(loaded);
					transmitByte(ret_char);
				}else
				{
					memset(eeprom_sim,0xFF,size);
					// eeprom_read_block(dest, src, size)
					eeprom_read_block((void*)eeprom_sim,(const void *)(eepromString+start_addr),(size_t)size);
					j = 0;
					for(i = 0;i < size;i++)
					{
/*
						if(eeprom_sim[i] == 0xFF)
							transmitByte('_');
						else
						{
							transmitByte(eeprom_sim[i]);
						}
*/
						transmitByte(eeprom_sim[i]);
						j++;
					}
					transmitByte((UCHAR)j);
					transmitByte((UCHAR)(j>>8));
				}		
			break;

			case 'e':
//				GDispStringAt(0,0,"print pattern 1");
//				_delay_us(100);
				test1 = 0x21;
				GDispClrTxt();
				for(row = 0;row < ROWS-1;row++)
				{
					for(col = 0;col < COLUMN-1;col++)
					{
						GDispCharAt(row,col,test1);
						_delay_ms(2);
						if(++test1 > 0x7e)
							test1 = 0x21;
					}
				}
				transmitByte(ret_char);
			break;

			case 'f':
//				GDispStringAt(0,0,"print pattern 2");
//				_delay_us(100);
				test1 = 0x7e;
				GDispClrTxt();
				for(row = 0;row < ROWS-1;row++)
				{
					for(col = 0;col < COLUMN-1;col++)
					{
						GDispCharAt(row,col,test1);
						_delay_ms(2);
						if(--test1 < 0x21)
							test1 = 0x7e;
					}
				}
				transmitByte(ret_char);
			break;

			case 'g':
				test1 = 0x7e;
				GDispClrTxt();
				for(row = 0;row < ROWS-1;row++)
				{
					for(col = 0;col < COLUMN-1;col++)
					{
						GDispCharAt(row,col,test1);
						_delay_ms(2);
						if(--test1 < 0x21)
							test1 = 0x7e;
					}
				}
				test1 = 0x21;
				GDispClrTxt();
				for(row = 0;row < ROWS-1;row++)
				{
					for(col = 0;col < COLUMN-1;col++)
					{
						GDispCharAt(row,col,test1);
						_delay_ms(2);
						if(++test1 > 0x7e)
							test1 = 0x21;
					}
				}
				GDispClrTxt();
				for(row = ROWS-1;row > 0;row--)
				{
					for(col = COLUMN-1;col > 0;col--)
					{
						GDispCharAt(row,col,test1);
						_delay_ms(2);
						if(--test1 < 0x21)
							test1 = 0x7e;
					}
				}
				test1 = 0x21;
				GDispClrTxt();
				for(row = ROWS-1;row > 0;row--)
				{
					for(col = COLUMN-1;col > 0;col--)
					{
						GDispCharAt(row,col,test1);
						_delay_ms(2);
						if(++test1 > 0x7e)
							test1 = 0x21;
					}
				}
				transmitByte(ret_char);
			break;

			case 'j':
				GDispClrTxt();
			break;

			default:
			break;
		}
	}
	return 0;
}


