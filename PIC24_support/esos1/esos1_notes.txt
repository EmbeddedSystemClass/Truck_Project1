4/9/18
The previous version of Truck_Project1 used an AVR chip as the driver for the LCD screen.
The PIC24 passed the keypresses from the keypad to the AVR. After deciding to make the 
menuing configurable by implementing the menu_struct system it got too complicated because
both the AVR and the PIC24 had to keep track of what the current menu was. 

Now that the PIC24 handles both the keypresses and the LCD screen display, the test bench
has to be setup so that one of the uarts of the PIC24 sends the output to the LCD to the
uart which goes to a linux box running a screen simulator. A linux program reads the 
serial port and uses ncurses calls to simulate the LCD screen. A DEBUG define statement
routes the GDispXXX calls to the serial port which would normally go to the actual LCD.

In normal operation, the poll_keypad waits for a keypress and sends it to menu_task 
(formerly called comm2_task because comm2 was going to the AVR). 

The old simulator (in AVR_t6963/test_write_data) compiled 2 programs: sim_read & sim_write.
sim_read was compiled using the make_avr makefile which compiled AVR_menu and sim_read and
simulated the AVR driving the LCD. The make_pic makefile compiled PIC_menu and sim_write 
which simulated the PIC24 sending serial commands to the AVR. (The current version did away
with the AVR_t6963 directory so you would have to back out the changes using git checkout).

The main loop in sim_write got the keypresses using the nucurses call: wgetch() and converted
the keypresses '0' -> '9', 'A' -> 'D', '*' and '#' to the KP_ equivalents defined in the key_types
enum and any other keypresses were converted to the alt keys like BURN_PART, LOAD_RAM, TEST1 -> TEST11
and so on. The sim_read would get read the output of sim_write and send it to read_get_key in
AVR_menu which is a giant switch/case statement that filters out all the alt keys and at the end
as the default, calls generic_menu_func() which does the actual menuing. All the alt functions
simulate the TS-7XXX sending extra commands to the PIC24 so it can do other stuff like load
the labels and changed the menuing system. 

The read_get_key() in sim_write simulates the poll_comm1_task in the PIC24 which filters out
all the alt keys like TEST1 and sends them to the uart2 mailbox in another giant switch/case
statement.

		if(wkey == TEST1)
		{
			low_byte = TEST1;
			__esos_CB_WriteUINT8(send_comm_handle->pst_Mailbox->pst_CBuffer,low_byte);
		}
		else if(wkey == TEST2)
		...
		
The default at the end of this switch/case statement sends whatever keys not filtered out
(the KP_XXX keypad keys) to 
		...
		else if(wkey == SPACE)
		{
			low_byte = SPACE;
			__esos_CB_WriteUINT8(send_comm_handle->pst_Mailbox->pst_CBuffer,low_byte);
		}
		else
			__esos_CB_WriteUINT8(menu_task_handle->pst_Mailbox->pst_CBuffer,wkey);
			
The whole point is so that the input from one of the serial ports on the PIC24 can simulate
the keypresses as well as send the alt key commands. Both poll_keypad and the default for
poll_comm1 send KP_XXX keys to the menu_task. So you could have the actual key pad working 
and simulate it at the same time using the test serial port (comm1). In actual practice, the
comm1 is comming from the TS-7XXX, comm2 is for the FPGA and comm3 is available as a monitor.

So now I just have to modify the old sim_read program so it works with the new GDispXXX calls
from the PIC24 that are DEBUG redefined. The new sim program will use the wgetch() to get a
keypress just like the sim_write did then wait for a sequence of bytes on the serial port
that basically tell what chars to display on the 'screen' and where. (To make things more
complicated, I renamed comm2_task in the old version to menu_task). 

Now we need 3 mailboxes, one for sending raw chars to the uart1, another for sending strings,
and another for sending hex chars. Then just use '#ifdef DEBUG' or '#ifndef DEBUG' to send
either debug messages (to the sim program running on a linux box) or normal messages to the
TS-7XXX.