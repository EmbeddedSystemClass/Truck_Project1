io_box.txt - notes on the box with the TS-7200 card and the (2) 20 port IO cards

Relays on IO cards are 5A so use 5v power from separate DC-DC converter as coil voltage for 10A 
relay arrays. (note: DO NOT use 5v from inside box - if you happen to short the 5v to gnd or
even worse, 12v you can screw up the cards inside the box - this cost me a day or so of trouble-
shooting and rewiring the io box)

typedef struct o_data
{
	char label[OLABELSIZE];
	UCHAR port;
	UCHAR onoff;			// current state: 1 if on; 0 if off
	UCHAR input_port;		// input port which affects this output (if not set to 41)
	UCHAR polarity;			// 0 - on input turns output on; off input turns output off
							// 1 - on input turns output off; off input turns output on
	UCHAR type;				// see below
	UINT time_delay;		// when type 2-4 this is used as the time delay
	UINT time_left;			// gets set to time_delay and then counts down
	UCHAR pulse_time;		// not used
	UCHAR reset;			// used to make 2nd pass
} O_DATA;

/*
type:
0) regular - on/off state responds to assigned input (affected_output)
1) goes on/off and stays that way until another on/off
2) on for time_delay seconds and then it goes back off
3) goes on/off every second until time_delay is up
4) if on, turn off and wait for msg (serial or tcp) to turn back on
6) goes on/off at pulse_time rate in 10ths of a second then
	goes off when time_delay is up
7) goes on/off at pulse_rate in 10ths of a second if onoff is 
	active only (not implemented yet)

type 6 & 7 not implemented yet

reset is used when type is 1 and 2: when type 1 it sets reset on the 1st pass
and then on 2nd pass it will change the output - 2 for time delay - there is
a loop in the timer task which checks all the output records for type 2 and
counts down using the time_left field.

When input_port field is set to anything less than 40, then this refers to the
input port which triggers the output - e.g. port 0 turns on/off the headlights,
so both LHEADLAMP and RHEADLAMP are activated by a switch going to port 0.

input_types

	HEADLAMP_INPUT,				// 0
	RUNNING_LIGHTS_INPUT,		// 1
	LEFTBLINKER_INPUT,			// 2
	RIGHTBLINKER_INPUT,			// 3
	BRIGHTS_INPUT,				// 4
	STARTER_INPUT,				// 5
	COOLINGFAN_INPUT,			// 6
	ESTOP_INPUT,				// 7
	BRAKE_INPUT					// 8

filename: odata.dat 

port	onoff	input_port	type	time_delay	label

0		0		5			2		10			STARTER
1		0		7			4		0			ACCON
2		0		7			4		0			FUELPUMP
3		0		6			0		0			COOLINGFAN
4		0		0			0		0			LHEADLAMP
5		0		4			0		0			LBRIGHTS
6		0		0			0		0			RHEADLAMP
7		0		4			0		0			RBRIGHTS
	
8		0		2			3		15			LEFTBLINKER
9		0		3			3		15			RIGHTBLINKER
10		0		1			0		0			RUNNINGLIGHTS
11		0		8			0		0			RBRAKELIGHT
12		0		8			0		0			LBRAKELIGHT
13		0		2			2		15			XLBLINKER
14		0		3			2		15			XRBLINKER
15		0		41			0		0			BATTERYCOMPHEATER

16		0		41			0		0			CRANKCASEHEATER
17		0		41			0		0			ESTOPSWITCH		// don't think I need this
18		0		41			0		0			BATTERYHEATER
19		0		41			0		0			TRLEFTBLINKER
20		0		41			0		0			TRRIGHTBLINKER
21		0		41			0		0			INTRUDERALARM
22		0		41			0		0			LIGHTBAR
23		0		41			0		0			BLINKINDICATE
	
24		0		41			0		0			ALARMSPEAKER
25		0		41			0		0			BACKUPLIGHTS
26		0		41			0		0			HTRBLOWERLOW
27		0		41			0		0			HTRBLOWERMED
28		0		41			0		0			HTRBLOWERHIGH
29		0		41			0		0			TESTOUTPUT27	// these not used yet
30		0		41			0		0			TESTOUTPUT28
31		0		41			0		0			TESTOUTPUT29

32		0		41			0		0			TESTOUTPUT30
33		0		41			0		0			TESTOUTPUT31
34		0		41			0		0			TESTOUTPUT32
35		0		41			0		0			TESTOUTPUT33
36		0		41			0		0			TESTOUTPUT34
37		0		41			0		0			TESTOUTPUT35
38		0		41			0		0			TESTOUTPUT36
39		0		41			0		0			NULL
	
monitor_input_task scans all the outputs using ollist_find_data and if type != 0 && onoff == 1 then
read last_time_state_changed (UINT) in current O_DATA and check against current time using localtime
in this case onoff == 1 means its active 

monitor_input_task does the scanning of the actual input ports and changes the outputs accordingly

monitor_fake_input_task scans an array called fake_inportstatus1 & 2 set by change_inputs()
so the outputs can be set implicitly.


config jumpers for io card:
base address		JP1		JP2
0x240				0		0
0x260				0		1
0x280				1		0
0x300				1		1

JP1 	JP2 (see note 1)
123		123
on for JP1 is jumper from 1->2
on for JP2 is jumper from 2->3

card on top is configured starting at 0x280
bottom card is 0x300 

PortA outputs 0x280	(8 bits)
PortB outputs 0x281	(8 bits)
PortC outputs 0x282	(4 bits)

PortD outputs 0x300	(8 bits)
PortE outputs 0x301	(8 bits)
PortF outputs 0x302	(4 bits)

PortA inputs 0x284	(8 bits)
PortB inputs 0x285	(8 bits)
PortC inputs 0x286	(4 bits)

PortD inputs 0x304	(8 bits)
PortE inputs 0x305	(8 bits)
PortF inputs 0x306	(4 bits)
(see ioports.h)

relays start at upper left and go down then lower right and go up (see note 1)

		left side		right side

		1				20
		2				19
		3				18
		4				17
		5				16
		6				15
		7				14
		8				13
		9				12
		10				11

inputs start from left (see note 1)
note 1) looking at card from component side w/PC-104 on bottom:

when compiling for TS-7200:
edit thread_io/Makefile so it compiles for TS-7200:

#use this for TS-7200
CC_FLAGS = -static -g -DMAKE_TARGET -Wstrict-prototypes -mcpu=arm920t
#use this for TS-7800
#CC_FLAGS = -static -g -DTS_7800 -DMAKE_TARGET -Wstrict-prototypes -mcpu=arm920t

the client program (in ncurses directory) takes the ip address as the 1st param
the 2nd & 3rd params are optional idata & odata files.

 "192.168.42.146"	TS-7200
 "192.168.42.148"		"
 "192.168.42.149"		"	<- using this one in IO box
 "192.168.42.145"	TS-7250
 "192.168.42.124"	TS-7250

if using the make file for the simulator: thread_io/linux_make, 
use the ip address for the linux box as 1st param for client
of the linux box that the sched simulator is running on

perf board for flashing light and 2 buttons:

pins at bottom:
1) +5v
2) gnd
3) LED light (to DIO1 7)
4) green button (to DIO1_0)
5) read button (to DIO1_1)

pinout for RJ-45 jack break-out

green /w	3	5	blue /w
green		6	4	blue
brown /w	1	7	brown /w
orange		2	8	brown

small switch on upper right front panel is console switch:
console = comm1 (left)
console off (right)

to mount sd card for TS-7200 see thread_io/how2formatSDCardExt.png and mountcf.sh
(also see: https://www.tldp.org/HOWTO/Flash-Memory-HOWTO/ext2.html)

to manage TS-7200 redboot see thread_io/manage_boot_bios.txt 
(if cant' get back downto linux shell)

40-pin ICD connector on side of IO box starts with port 0 on top right and
goes to port 19 on top left, then starts with port 20 on lower right and goes
to left (port 39)

19 18 17 16 15 14 13 12 11 10  9  8  7  6  5  4  3  2  1  0		-> front of IO box
39 38 37 36 35 34 33 32 31 30 29 28 27 26 25 24 23 22 21 20

need a way to save the odometer reading to disk.
Use the llist type database files to add another type to record the real-time data:
time from engine start or total time (trunning_hours/minutes/seconds)
no - just create a file called odometer.txt and write an int to it.

8/8/18 - getting intermittent segment fault when doing change_output() - seems to
happen more often when doing using tcp command but never does it from within
monitor_input_task ~? - something flakey about card 146 - 149 works ok

8/13/18 - thread_io was causing segment fault crash because when live window was up there was some
un received tcp messages so I set the get_sock call in tcp_win2 to non-blocking and that seemed to 
fix it.

9-14-18 - added a new type to O_DATA (type 4) to be used as a lockout relay. The E-Stop switch is connected
to port 19 and affects outputs 1 & 2 (ignition and fuel pump). The types for 1 & 2 are set to type 4
so when the E-Stop switch is pressed it will turn then off so they stay off unless a special message
(_RESET_TYPE4) is sent which resets the reset field to 0. They have to be turned on not by using the 
change_input but change_output function.

Then a msg will be sent to the PIC24 that tells it that the E-Stop button was pressed so it can ask 
for the password to be re-entered or shutdown everything.

in tasks.c serial_recv_task() if byte recv'd is RT_DATA then recv the ADC channels
from the PIC24 which are sent from send_comm1

tasks.c sends data to PIC24 using write_serial at several places prefixed by the commands:
CLEAR_SCREEN
GET_DEBUG_INFO
GET_DEBUG_INFO2
OUTPUT_MSG
these all must be a total of 5 bytes including the command - they are received by recv_comm1
in the PIC24

todo: (x) = done

- get rpm/mph data sent to comm3 of PIC24 (x)
- thread_io just sends current time once a minute or 30 minutes - PIC24 keeps track of time with timer_task
- setup spare AVR to generate sample rpm/mph signals to test LEDs
- fix problem with client - host open, edit and save file
- only I_DATA type that explicitly turns on and off is type 2 & 3 (time delay). If set to toggle
	then polarity feature could be implemented but the current IO settings would have to be set
	initially after loading the db and the db would have to be save on exit
- wired 1st 2 relays as left br/dim and right br/dim (nc = dim) and 3rd & 4th relays as
	left & right headlamps - common of 1st 2 comes from no of next 2 - dim is nc on 1st 2 so make
	changes accordingly in the O_DATA.
	
Wiring colors:
	Front:	(going threw terminal block on pass-side fender well
	Orange	-	LBRIGHTS
	White	-	RBRIGHTS
	Grey	-	LHEADLAMP
	Purple	-	RHEADLAMP
	Blue	-	ACCON
	Brown	-	STARTER
	Green	-	(to extra relay)
	Yellow	-		"	"
	Black	-		"	"

	
	Rear:
	Orange	-	RBRAKELIGHT
	White	-	LBRAKELIGHT
	Grey	-	LEFTBLINKER
	Purple	-	RIGHTBLINKER
	Blue	-	RUNNINGLIGHTS
	Brown	-	BACKUPLIGHTS
	Green	-	TRLEFTBLINKER
	Yellow	-	TRRIGHTBLINKER
	Black	-	TRAILERBRAKES
	(extra wires from blinkers and running lights
	also go to front)

Work-around for tail-light delima:
The tail light has 2 filements: 1 dim and 1 bright. The dim is one of the running-lights. So
what happens if you press on the brakes and the blinkers at the same time? There are 2 outputs
for each tail-light, blinker and brake. When the brakes are on the blinker is supposed to
flash the bright while the other brake stays on. So make the inputs to the blinkers reference
an additional ouput which goes to a coil which shuts off the brake light relay so the blinker
can flash it. 
