<h1>Truck_Project1</h1>
<br />
Truck_Project1 is an automotive SCADA system which uses a Xilinx Spartan-3E to <br />
monitor real-time data, a STM32F100RB to handle a keypad and route message<br />
traffic, and a TS-7200/7800 to do I/O (turning on and off lights and reading switches).<br />
The STM32F100RB (STM32) will route message traffic to and from the FPGA, the <br />
TS-7200 and handle the keypad input.<br />
<img src="Images/SystemDiagram.JPG">
<br />
A Windows 10 TCP client runs on a laptop and the VGA port is connected to an external 8"<br />
monitor in the dash as the UI<br />
<img src="Images/ClientUI.JPG">
Because the fact that the STM32 has no ethernet connection, and only communicates with<br />
the TS-7200 via a serial port, the message passing gets really complicated.<br />
Add to that, the fact that I want to be able to send messages using the keypad as well as<br />
the Windows client to the TS-7200.<br />
<h2>Using the keypad</h2>
The keypad buttons, for now, do the basic functions I need:<br />
<li> '1' - start engine</li>
<li> '2' - stop engine</li>
<li> '3' - brights</li>
<li> '4' - cooling fan</li>
<li> '5' - heater blower</li>
<li> '6' - running lights</li>
<li> '7' - headlamps</li>
<li> '8' - wipers</li>
<li> '9' - not used</li>
<li> '0' - not used</li>
Note: when you press '1' to start the engine, it only powers the relays for the ignition,<br />
fuel pump, and completes a circuit to a button on the dash to power the starter solinoid.<br />
Then, the code in the TS-7200 only gives you 10 seconds to start the engine. After that,<br />
the starter solinoid is disabled.<br />
The 'stop engine' button (2) will turn off the ignition and fuel pump<br />
The keys: A->D navigate the bottom 10 buttons on the windows client starting with 'Start Engine'<br />
going down to 'Settings Three', then up to 'Play List' and then down to 'Settings Four'.<br />
The system will operate without the laptop, but you can only use the numbered buttons on<br />
the keypad. The messages generated by the lettered buttons are routed to the Windows client<br />
The buttons labeled 'Test Ports', 'Settings One/Two/Three/Four' call up child dialogs that<br />
send messages to the TS-7200. The text on the button and the message it sends can be edited<br />
by changing xml files.<br />
<h2>The STM32 processor</h2>
The STM32F100RB is in the subdirectory 'STM32' and was generated using STM32CubeMX and compiled<br />
with TrueStudio. The project uses FreeRTOS as the operating system. Currently, all but 3 pins<br />
are used so the next step is to upgrade to a better STM32 chip.<br />
<img src="Images/STM32pinout.JPG">
What's shown here is the pinout that STM32CubeMX reports. I added some user code in the gpio.c<br />
file that added the pins for the 2 DS1620's. There are sections in the generated code that<br />
are reserved for user editing. Anything outside these sections gets removed if you pull the<br />
project back into CubeMX. I had to do it this way because the data pin on the DS1620 is<br />
changed from input to output. One of the routines generated is a callback for a 1 second<br />
timer which reads the temp settings to turn the cooling fan on or off according to what the<br />
DS1620 for engine temp reads. (The DS1620 is mounted on the thermostat housing). The other<br />
DS1620 is in the cab and reads the indoor temp. A section in the timer callback turns on/off<br />
the blower for the heater depending on the indoor temp.<br />
<h2>The Xilinx processor</h2>
I use a Spartan-3E Xilinx FPGA board to monitor real-time data like engine RPM,MPH. It sends<br />
data to the STM32 over a parallel port. The STM32 sends data to the FPGA board over a<br />
RS-232 port and uses handshaking signal. Two sensors are connected to the FPGA board which<br />
are converted to RPM/MPH readings. One sensor comes from a hall-effect switch on the driveshaft<br />
and another comes from a light sensor on the crankshaft. The FPGA also gets messages from the<br />
STM32 to generate DTMF tones whenever the keys on the keypad are pushed. The data from the<br />
RPM/MPH is sent over a parallel port to the STM32 which sends it on to the client and also<br />
sent to an XMEGA processor over a serial line which drives two LCD displays mounted on the dash.<br />
<h2> The IO box (TS-7200)</h2>
<img src="Images/iobox.JPG">
I'm using a TS-7200 embedded linux card from Technologic which has a PC-104 card connector. (shown on left)<br />
The card runs linux compiled for the ARM processor on the card. When it gets powered up, it automatically<br />
starts an app called 'sched' which uses POSIX threads and runs as a TCP/IP server. The ethernet port is<br />
extended to an RJ-45 socket on the outside of the box where the cross-over cable plugs into.<br />
The picture on the right shows the 2 PC-104 IO cards mounted on top of it. Each card has 20 input and output<br />
ports; The outputs are the small 5A relays, 10 on each side, and the inputs come from the grey ribbon cable.<br />
The outputs of the small 5A relays go to other 10A relays which control low voltage 12Vdc circuits like the<br />
running lights and blinkers, while the higher amperage circuits like the headlights and starter solinoid are<br />
controlled by 10-30A cube relays. The serial port next to the ethernet port goes to the STM32. So there is no<br />
way to upload a new sched program to the iobox because on the bench, I have to ftp into it from another linux<br />
desktop. When it's in the vehicle, I have to use a Windows app called 'SendFiles' which makes an FTP connection<br />
to the linux server after the sched program exits with a special code. There is another ARM compiled program<br />
on the linux server called 'server' which downloads the new sched program from the SendFiles program running<br />
on the client. After downloading, the system is rebooted. This is all handled by a bash script in the sched<br />
directory called 'try_sched.sh' which gets called when the linux card boots up. So if I make a change to the<br />
client where the message list is different and try to run it before uploading the new sched, I have to pull<br />
it in the garage and move a linux desktop inside and ftp into it.<br />
There is also an 2 line LCD screen (not shown) on the iobox that scrolls the messages that come to the sched.<br />
<h2>The LCD screen</h2>
<img src="Images/LCD_screen.jpg">
I originally was using a t6963 LCD screen with an AVR Pro-Mini on the back of it which got serial commands<br />
from UART2 of the STM32. I was trying to do some kind of user input from the keypad which got too problematic<br />
so I went to using the Windows laptop as the UI. This is not show on the system diagram at the top, but I will<br />
have to, at some point re-install it when I start running out of room to display RT data on the Windows screen.<br />
All the code for the AVR processor is in the AVR_t6963 directory. At one time I had a PWM signal coming from<br />
the FPGA board which would dim the LCD screen.<br />
<h2>The Home Server</h2>
<img src="Images/ClientUI2.JPG">
I'm currently working on another Windows C# app which works just like the client, only it's a TCP<br />
server which runs on the desktop in the garage and only works when the truck is parked just outside.<br />
There are 2 network connections on the client. One is threw an ethernet cross-over cable plugged<br />
directly into the TS-7200 iobox and the other is a WiFi connection. When I start the client app<br />
on the laptop, I have to connect to the TS-7200 using the top-left button called 'Connect'.<br />
Then I can close the lid on the laptop, put it under the seat and use the keypad to navigate<br />
the 10 buttons on the bottom. The button called 'Call Home' will connect to the Home Server<br />
and then I can go back in the garage and while the engine is warming up, set config parameters<br />
and control the lights, blower and shut off the engine for what it's worth. The picture shows<br />
the home server on the lower-right and the status window of the client (running on my desktop)<br />
on the upper-left. The blue window on the upper-right is just a tty connected to an extra comm port<br />
on the TS-7200 which just shows debug messages. The messages scrolling on the edit boxes are from<br />
clicking on the buttons on the home server. The main purpose of the home server is to set configuration<br />
parameters which get saved to a file on the TS-7200.<br />
<h2>Configuration Parameters</h2>
<img src="Images/DlgSetParams.JPG">
The 3 buttons on the lower-right of the home server are used to manage the configuration parameters.<br />
The 'Get Params' button gets the parameters from the param.conf file which stores the params on disk(TS-7200).<br />
The 'Config Params' button pulls up a dialog (show above) on the home server where the user can modify the<br />
params. The 'Upload Params' button loads the params needed by the STM32 to control the cooling and heater fan.<br />
Namely, the temperatures on the left. There is also a way to set the params on the Windows client.<br />
<h3>List of config params on TS-7200</h3>
<li>rpm_update_rate</li>
<li>mph_update_rate</li>
<li>fpga_xmit_rate</li>
<li>high_rev_limit</li>
<li>low_rev_limit</li>
<li>cooling_fan_on</li>
<li>cooling_fan_off</li>
<li>blower_enabled</li>
<li>blower1_on</li>
<li>blower2_on</li>
<li>blower3_on</li>
<li>lights_on_delay</li>
<li>engine_temp_limit</li>
<li>batt_box_temp</li>
<li>test_bank</li>
The update rates are not implemented yet, but will control how fast the RPM/MPH data is sent to the displays.<br />
The high/low rev limit are for the rev limiter.<br />
The cooling fan on/off determine at what engine temps the cooling fan goes on or off. Hopefully the fan on is higher<br />
than the fan off.<br />
The blower_enabled is the engine temp at which the STM32 even responds to the indoor temps to control the heater.<br />
The blower1_on is the highest indoor temp at which the blower runs on low speed.<br />
The blower2_on is the medium speed temperature.<br />
The blower3_on is the highest speed temperature.<br />
So the blower will come on high speed when the indoor temp is below what the blower3_on temp is set to.<br />
The blower will switch to medium speed when the indoor temp reaches blower2_on temp, and will switch to<br />
low speed when the indoor temp is between blower1_on and blower2_on, and finally go off when above blower1_on.<br />
The lights on delay is how many seconds the lights/running lights stay on after the engine shuts off.<br />
The engine_temp_limit is the engine temperature at which an alarm sounds. Currently the engine doesn'nt shut<br />
down at too high a temp, but at some point in the future it should, along with the oil pressure which isn't hooked up yet.<br />
The battery box temp is for the heat strip underneath the battery which is behind the passenger seat.<br />
<h2>More about the Windows Client</h2>
<img src="Images/ChildDialog.JPG">
The buttons labeled: 'Test Ports', 'Settings One/Two/Three/Four' call up a child dialog which works the same with<br />
the A->D keys on the keypad as they do on the main screen of the client screen. 'A' moves up, 'B' moves down, '*' moves<br />
to the opposite column, 'C' executes whatever the key applies to, and 'D' closes or exits. Each button on the main<br />
screen are assigned an xml file, so I can edit the name of each button on the child dialog and what it does as far as<br />
what message it passes to the linux server. So the 3rd button down on the right labeled 'Lights On/Off' will toggle the<br />
headlights on and off. There is another type of child dialog that is set by xml files which is a scrolling list of values<br />
to choose from. Most of the scrolling list dialogs are used to set the config parameters.<br />
