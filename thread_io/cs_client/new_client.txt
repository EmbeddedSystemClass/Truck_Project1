new client that runs on Windows 10 laptop compiled with VS2017 using C#

This program duplicates what the client running on linux using ncurses did:

1) send commands to server (io box) to turn on/off relays for starter, ignition & fp, etc.
2) send and receive a copy of the database.
3) connect/disconnect from the server.
4) set the time on the server.
5) get a list of the *.dat files on the server in the /home/dan/dev/sched directory
6) shutdown/reboot the server

The one main difference is that the databases are stored on an sql server on the 
laptop and are manipulated with datasets, tables and data adapters and there is
a grid to view the table. The *.dat files (idata.dat odata.dat) are flat files
that are read by the server to keep track of the io states. Currently the sql
databases only use the odata.dat format (O_DATA).

Current features:
1) a button called 'Send Data' which sends the entire record in 
	the table to the server. 
2) a pull-down list box called 'Update Single Record' which shows a list of the
	labels and sends the current record in the datagrid as just the label, onoff,
	type & time_delay fields.
3) a list of checkboxes on the left to turn on/off the common relays: 
	a) starter
	b) ignition
	c) fuelpump
	d) cooling fan
	e) lights
	f) brights
(this will go away because it should be set from the database only because
these port assignments can change)
4) a button which reads an xml file of the table and loads it to the grid
5) a button to show what's in the current database.
6) a button to update the db with what's in the grid

todo:
- option to write current table (in grid or in db) to an xml file
- option to set the time on the server (since there is no rtc yet) (x)
- option to choose which table in the database to:
	a) load to the grid to edit
	b) send to the server
	c) save to xml file
- option to stop the server and have it load either a new database sent over
	using the send data button or load another dat file on the server
- the input ports don't have to necessarily match 1 for 1 each output port
	for instance, the starter, ignition & fuelpump does not have an
	input switch so the inputs marked as STARTER, ACCON, & FUELPUMP
	are never used. The inputs can just as easily start with HEADLIGHTS,
	RUNNING_LIGHTS, BRAKE_SWITCH or anything where a physical switch is
	hooked up as an input to the io box. They will just have to be
	re-directed to whatever output port it affects. So the I_DATA db
	in the io box running on linux doesn't have to be exactly 40 ports
	like the O_DATA. It should match the SQL datafile. In fact, the SQL
	datasource for I_DATA should have joins showing what input affects
	which output.
- the only O_DATA fields the user needs to change are:
	- onoff, polarity, type, pulse_time & time_delay. the others are used internally
	by the linux program. (polarity & pulse_time ain't implemented yet)
- another table can be set up in as an SQL database and used to do programmed
	future events, like turn on the battery warmer at a certain time or temp.
	Also there is the possibility of executable scripts or functions.
- actually, the I_DATA is not really needed - the O_DATA can have a field that
	specifies which input is affected by it, if any. The way it's setup now,
	one input can affect one or more outputs. But would it be useful for more
	than one input to affect a single output? Can't think of any reason to do 
	that:
	
input 1 affects -> output 1,2 & 3

inputs 1,2 & 3 affects -> output 1	

So just have a field in each O_DATA record that specifies which input is affected
by it. And if one input can affect more than one output, then the 2 outputs affected
would have that field set to the same input.
